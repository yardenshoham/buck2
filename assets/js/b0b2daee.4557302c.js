"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4742],{3905:(e,t,a)=>{a.r(t),a.d(t,{MDXContext:()=>m,MDXProvider:()=>u,mdx:()=>N,useMDXComponents:()=>s,withMDXComponents:()=>p});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},r.apply(this,arguments)}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function d(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var m=n.createContext({}),p=function(e){return function(t){var a=s(t.components);return n.createElement(e,r({},t,{components:a}))}},s=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):d(d({},t),e)),a},u=function(e){var t=s(e.components);return n.createElement(m.Provider,{value:t},e.children)},c="mdxType",x={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=s(a),u=i,c=p["".concat(l,".").concat(u)]||p[u]||x[u]||r;return a?n.createElement(c,d(d({ref:t},m),{},{components:a})):n.createElement(c,d({ref:t},m))}));function N(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=h;var d={};for(var o in t)hasOwnProperty.call(t,o)&&(d[o]=t[o]);d.originalType=e,d[c]="string"==typeof e?e:i,l[1]=d;for(var m=2;m<r;m++)l[m]=a[m];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},6716:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>s,frontMatter:()=>r,metadata:()=>d,toc:()=>m});var n=a(87462),i=(a(67294),a(3905));const r={id:"rule_api",title:"Rule APIs"},l=void 0,d={unversionedId:"rule_authors/rule_api",id:"rule_authors/rule_api",title:"Rule APIs",description:"When implementing a rule, you are given a value of type context and are expected to produce providers. This page details those providers and the attributes and APIs that they offer.",source:"@site/../docs/rule_authors/rule_api.md",sourceDirName:"rule_authors",slug:"/rule_authors/rule_api",permalink:"/docs/rule_authors/rule_api",draft:!1,tags:[],version:"current",frontMatter:{id:"rule_api",title:"Rule APIs"},sidebar:"manualSidebar",previous:{title:"Writing Rules",permalink:"/docs/rule_authors/writing_rules"},next:{title:"Transitive Sets",permalink:"/docs/rule_authors/transitive_sets"}},o={},m=[{value:"Providers",id:"providers",level:2},{value:"Type <code>context</code>",id:"type-context",level:2},{value:"Type <code>actions</code>",id:"type-actions",level:2},{value:"Type <code>cmd_args</code>",id:"type-cmd_args",level:2},{value:"Type <code>label</code>",id:"type-label",level:2},{value:"Type <code>artifact</code>",id:"type-artifact",level:2},{value:"Projected artifacts",id:"projected-artifacts",level:3}],p={toc:m};function s(e){let{components:t,...a}=e;return(0,i.mdx)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"When implementing a rule, you are given a value of type ",(0,i.mdx)("inlineCode",{parentName:"p"},"context")," and are expected to produce providers. This page details those providers and the attributes and APIs that they offer."),(0,i.mdx)("h2",{id:"providers"},"Providers"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},'DefaultInfo(default_outputs : ["artifact"], other_outputs : [["artifact", "cmd_args"]] = [], sub_targets : {str.type: ["provider"]} = {})')," - the provider that is used for:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"buck2 build")," - builds everything in ",(0,i.mdx)("inlineCode",{parentName:"li"},"default_outputs")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"other_outputs"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"$(location)")," - uses the ",(0,i.mdx)("inlineCode",{parentName:"li"},"default_outputs"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"buck2 build my_target[foo]")," - selects the ",(0,i.mdx)("inlineCode",{parentName:"li"},"foo")," value from ",(0,i.mdx)("inlineCode",{parentName:"li"},"sub_targets"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Note"),": if you use ",(0,i.mdx)("inlineCode",{parentName:"li"},"cmd_args")," in ",(0,i.mdx)("inlineCode",{parentName:"li"},"other_outputs"),", then it will expand to all the inputs referenced by the ",(0,i.mdx)("inlineCode",{parentName:"li"},"cmd_args")," you provide."))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"RunInfo(args)")," - used for ",(0,i.mdx)("inlineCode",{parentName:"li"},"buck2 run"),", where ",(0,i.mdx)("inlineCode",{parentName:"li"},"args")," is anything that can be converted into ",(0,i.mdx)("inlineCode",{parentName:"li"},"cmd_args"),", including a command line itself."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"ExternalRunnerTestInfo(...)")," - for details, see ",(0,i.mdx)("a",{parentName:"li",href:"/docs/rule_authors/test_execution"},"Test Execution"),".")),(0,i.mdx)("h2",{id:"type-context"},"Type ",(0,i.mdx)("inlineCode",{parentName:"h2"},"context")),(0,i.mdx)("p",null,"The starting type, usually bound as ",(0,i.mdx)("inlineCode",{parentName:"p"},"ctx"),"."),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"ctx.attrs")," - returns the attributes of the target as a Starlark struct with a field for each attribute, which varies per rule."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"ctx.actions")," - returns ",(0,i.mdx)("inlineCode",{parentName:"li"},"actions")," allowing you to define actions."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"ctx.label")," - returns a ",(0,i.mdx)("inlineCode",{parentName:"li"},"label")," representing the target.")),(0,i.mdx)("h2",{id:"type-actions"},"Type ",(0,i.mdx)("inlineCode",{parentName:"h2"},"actions")),(0,i.mdx)("p",null,"Most output filenames can either be artifacts created with ",(0,i.mdx)("inlineCode",{parentName:"p"},"declare_output")," or strings that are implicitly converted to output artifacts."),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"ctx.actions.declare_output([prefix], filename, dir = False)")," - returns an ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact")," with the name ",(0,i.mdx)("inlineCode",{parentName:"p"},"filename"),", which when asked for its name, will return ",(0,i.mdx)("inlineCode",{parentName:"p"},"filename")," (which may include a directory portion)."),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"prefix")," (optional) - provides a silent part of the filename, which can be used to disambiguate but whose presence will not be visible to anyone using the ",(0,i.mdx)("inlineCode",{parentName:"li"},"artifact"),". By default, outputs are considered files; pass ",(0,i.mdx)("inlineCode",{parentName:"li"},"dir = True")," to indicate it is a directory."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"declare_output")," - mainly used to produce an unbound artifact for passing to ",(0,i.mdx)("inlineCode",{parentName:"li"},"ctx.actions.run"),"."))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"ctx.actions.write(filename, content, is_executable : bool.type = false, allow_args : bool.type = false)")," - returns an ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact")," whose contents are ",(0,i.mdx)("inlineCode",{parentName:"p"},"content"),"."),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"filename")," - can be a string or an existing artifact created with ",(0,i.mdx)("inlineCode",{parentName:"li"},"declare_output"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"is_executable")," (optional) - indicates whether the resulting file should be marked with executable permissions."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"allow_args")," (optional) - must be set to ",(0,i.mdx)("inlineCode",{parentName:"li"},"True")," if you want to write parameter arguments to the file (in particular, macros that write to file).",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"If it is true, the result will be a pair of the ",(0,i.mdx)("inlineCode",{parentName:"li"},"artifact")," containing ",(0,i.mdx)("inlineCode",{parentName:"li"},"content")," and a list of ",(0,i.mdx)("inlineCode",{parentName:"li"},"artifact")," values that were written by macros, which should be used in hidden fields or similar."))))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"ctx.actions.write_json(filename, content, with_inputs = False)")," - returns an ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact")," whose contents are ",(0,i.mdx)("inlineCode",{parentName:"p"},"content")," written as a JSON value."),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"filename")," - can be a string, or an existing artifact created with ",(0,i.mdx)("inlineCode",{parentName:"li"},"declare_output"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"content")," - must be composed of the basic json types (Boolean, number, string, list/tuple, dictionary) plus artifacts and command lines.",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"An artifact will be written as a string containing the path."),(0,i.mdx)("li",{parentName:"ul"},"A command line will be written as a list of strings, unless ",(0,i.mdx)("inlineCode",{parentName:"li"},"joined=True")," is set, in which case it will be a string."))),(0,i.mdx)("li",{parentName:"ul"},"If you pass ",(0,i.mdx)("inlineCode",{parentName:"li"},"with_inputs = True"),", you'll get back a ",(0,i.mdx)("inlineCode",{parentName:"li"},"cmd_args")," that expands to the JSON file but carries all the underlying inputs as dependencies (so you don't have to use, for example, ",(0,i.mdx)("inlineCode",{parentName:"li"},"hidden")," for them to be added to an action that already receives the JSON file)."))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"ctx.actions.copy_file(dest, src)")," - copies the source ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact")," to the destination (which can be a string representing a filename or an output ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact"),") and returns the output ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact"),". The copy works for files or directories.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"ctx.actions.symlink_file(dest, src)")," - creates a symlink to the source ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact")," at the destination (which can be a string representing a filename or an output ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact"),") and returns the output ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact"),". The symlink works for files or directories.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},'ctx.actions.symlinked_dir(output, srcs : {str.type: "artifact"})')," - returns an artifact that is a directory containing symlinks. The ",(0,i.mdx)("inlineCode",{parentName:"p"},"srcs")," must be a dictionary of path (as string, relative to the result directory) to bound ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact,")," which will be laid out in the directory.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},'ctx.actions.copied_dir(output, srcs : {str.type: "artifact"}, copy : bool.type = false)')," - returns an artifact which is a directory containing copied files. The ",(0,i.mdx)("inlineCode",{parentName:"p"},"srcs")," must be a dictionary of path (as string, relative to the result directory) to the bound ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact"),", which will be laid out in the directory.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"ctx.actions.download_file(output, url : str.type, sha1: str.type, is_executable : bool.type = false)")," - downloads a URL to an output (filename as string or output ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact"),"). The file at the URL must have the given ",(0,i.mdx)("inlineCode",{parentName:"p"},"sha1")," or the command will fail. The optional parameter ",(0,i.mdx)("inlineCode",{parentName:"p"},"is_executable")," indicates whether the resulting file should be marked with executable permissions.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},'ctx.actions.run(arguments, category : str.type, identifier : str.type = "", env : {str.type: str.type} = {}, local_only : bool.type = false, always_print_stderr : bool.type = false, weight : int.type = 1, metadata_env_var: str.type = None, metadata_path: str.type = None, no_outputs_cleanup: bool.type = false)')," - runs a command."),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"arguments")," - must be of type ",(0,i.mdx)("inlineCode",{parentName:"li"},"cmd_args"),", or a type convertible to such (such as a list of strings and artifacts) and must contain at least one ",(0,i.mdx)("inlineCode",{parentName:"li"},".as_output()")," artifact."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"category")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"identifier")," - when used together, identify the action in Buck2's event stream, and must be unique for a given target."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"weight")," is used to note how heavy the command is and will typically be set to a higher value to indicate that less such commands should be run in parallel (if running locally)."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"no_outputs_cleanup")," - if this flag is set then Buck2 won't clean the outputs of a previous build that might be present on a disk; in which case, command from ",(0,i.mdx)("inlineCode",{parentName:"li"},"arguments")," should be responsible for the cleanup (that is useful, for example, when an action is supporting incremental mode and its outputs are based on result from a previous build)."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"metadata_env_var")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"metadata_path")," - both should either be set or unset.",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"metadata_path")," defines a path relative to the result directory for a file with action metadata, which will be created right before the command will be run.",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"Metadata contains the path relative to the Buck2 project root and hash digest for every action input (this excludes symlinks as they could be resolved by a user script if needed). The resolved path relative to the Buck2 project for the metadata file will be passed to command from ",(0,i.mdx)("inlineCode",{parentName:"li"},"arguments"),", via the environment variable, with its name set by ",(0,i.mdx)("inlineCode",{parentName:"li"},"metadata_env_var"),"."))),(0,i.mdx)("li",{parentName:"ul"},"Both ",(0,i.mdx)("inlineCode",{parentName:"li"},"metadata_env_var")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"metadata_path")," are useful when making actions behave in an incremental manner (for details, see ",(0,i.mdx)("a",{parentName:"li",href:"/docs/rule_authors/incremental_actions"},"Incremental Actions"),")"))))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"ctx.actions.tset(type, value = None, children = None)")," - creates a new transitive set (for details, see ",(0,i.mdx)("a",{parentName:"p",href:"/docs/rule_authors/transitive_sets"},"Transitive Sets"),").")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"ctx.actions.cas_artifact(output, digest : str.type, use_case: str.type, expires_after_timestamp: int.type, is_executable : bool.type = false)")," - downloads a CAS artifact to an output."),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"digest")," - must look like ",(0,i.mdx)("inlineCode",{parentName:"li"},"SHA1:SIZE"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"use_case")," - your RE use case."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"expires_after_timestamp")," - must be a UNIX timestamp. Your digest's TTL must exceed this timestamp. Your build ",(0,i.mdx)("em",{parentName:"li"},"will")," break once the digest expires, so make sure the expiry is long enough (preferably, in years)."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"is_executable")," (optional) - indicates the resulting file should be marked with executable permissions.")))),(0,i.mdx)("h2",{id:"type-cmd_args"},"Type ",(0,i.mdx)("inlineCode",{parentName:"h2"},"cmd_args")),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"cmd_args")," type is created by ",(0,i.mdx)("inlineCode",{parentName:"p"},"cmd_args")," and is consumed by ",(0,i.mdx)("inlineCode",{parentName:"p"},"ctx.actions.run"),". The type is a mutable collection of strings and ",(0,i.mdx)("inlineCode",{parentName:"p"},"artifact")," values. In general, command lines, artifacts, strings, ",(0,i.mdx)("inlineCode",{parentName:"p"},"RunInfo")," and lists thereof can be added to or used to construct a ",(0,i.mdx)("inlineCode",{parentName:"p"},"cmd_args")," value. All these methods operate mutably on ",(0,i.mdx)("inlineCode",{parentName:"p"},"cmd")," and return that value too."),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},'cmd_args(*args, format: str.type = "", delimiter: str.type = None, prepend: str.type = None, quote: str.type = None)')," - creates and returns a ",(0,i.mdx)("inlineCode",{parentName:"p"},"cmd_args")," type."),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"*args")," - a list of things to add to the command line, each of which must be coercible to a command line. Further items can be added with ",(0,i.mdx)("inlineCode",{parentName:"li"},"cmd.add"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"format")," (optional) - a string that provides a format to apply to the argument. for example, ",(0,i.mdx)("inlineCode",{parentName:"li"},'cmd_args(x, format="--args={}")')," would prepend ",(0,i.mdx)("inlineCode",{parentName:"li"},"--args=")," before ",(0,i.mdx)("inlineCode",{parentName:"li"},"x"),", or if ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")," was a list, before each element in ",(0,i.mdx)("inlineCode",{parentName:"li"},"x"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"delimiter")," (optional) - added between arguments to join them together. For example,  ",(0,i.mdx)("inlineCode",{parentName:"li"},'cmd_args(["--args=",x], delimiter="")')," would produce a single argument to the underlying tool."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"prepend")," (optional) - added as a separate argument before each argument."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"quote")," (optional) - indicates whether quoting is to be applied to each argument. Note: the only current valid value is ",(0,i.mdx)("inlineCode",{parentName:"li"},'"shell"'),"."))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"cmd.add(*args)")," - a list of arguments to be added to the command line, as per ",(0,i.mdx)("inlineCode",{parentName:"p"},"cmd_args"),".")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"cmd.hidden(*args)")," - things to add to the command line which do not show up but are added as dependencies.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"cmd.ignore_artifacts()")," - conceptually the opposite of ",(0,i.mdx)("inlineCode",{parentName:"p"},"hidden()"),". It causes none of the arguments of the command line to be added as dependencies."),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"Use this if you need the path to an artifact but ",(0,i.mdx)("em",{parentName:"li"},"not")," the artifact itself."),(0,i.mdx)("li",{parentName:"ul"},"Note:  if you do find yourself needing any of the inputs referenced by this command, you will hit build errors due to missing dependencies."))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"cmd.relative_to(directory, parent : int.type = 0)")," - complex magic. Before using this, please contact Meta's Buck2 team.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"cmd.absolute_prefix(prefix : str.type)"),"- adds a prefix to the front of every artifact.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"cmd.absolute_suffix(suffix : str.type)")," - adds a suffix to the end of every artifact.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"cmd.parent(count : int.type = 1)")," - uses the parent of all given artifacts. Often used as ",(0,i.mdx)("inlineCode",{parentName:"p"},'cmd_args(artifact, format="-L{}").parent()'),".")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"cmd.replace_regex(pattern : str.type, replacement : str.type)")," - replaces all parts matching ",(0,i.mdx)("inlineCode",{parentName:"p"},"pattern")," regular expression in each argument with ",(0,i.mdx)("inlineCode",{parentName:"p"},"replacement")," string. Several replacements can be added by multiple ",(0,i.mdx)("inlineCode",{parentName:"p"},"replace_regex")," calls.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"cmd.copy()")," - returns a copy of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"cmd_args")," such that any modifications to the original or the returned value will not impact each other.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"cmd.inputs")," - returns a list of the artifacts that are inputs to this command line.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"cmd.outputs")," - returns a list of the artifacts that are outputs of this command line."))),(0,i.mdx)("h2",{id:"type-label"},"Type ",(0,i.mdx)("inlineCode",{parentName:"h2"},"label")),(0,i.mdx)("p",null,"A label represents a configured target."),(0,i.mdx)("p",null,"For example, the label ",(0,i.mdx)("inlineCode",{parentName:"p"},"fbcode//buck2/hello:world (ovr_config//platform/linux:x86_64-fbcode-46b26edb4b80a905)")," has the following attributes:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"package")," gives back ",(0,i.mdx)("inlineCode",{parentName:"li"},"buck2/hello")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"name")," gives back ",(0,i.mdx)("inlineCode",{parentName:"li"},"world")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sub_target")," gives back ",(0,i.mdx)("inlineCode",{parentName:"li"},"None")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"path")," gives back ",(0,i.mdx)("inlineCode",{parentName:"li"},"fbcode/buck2/hello")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"cell")," gives back ",(0,i.mdx)("inlineCode",{parentName:"li"},"fbcode")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"raw_target()")," gives back ",(0,i.mdx)("inlineCode",{parentName:"li"},"fbcode//buck2/hello:world")," without the configuration")),(0,i.mdx)("h2",{id:"type-artifact"},"Type ",(0,i.mdx)("inlineCode",{parentName:"h2"},"artifact")),(0,i.mdx)("p",null,"An artifact, which has a location on disk. Some of that location is considered private, and some (the suffix) is available for use."),(0,i.mdx)("p",null,"The examples below assume an artifact such as one created with ",(0,i.mdx)("inlineCode",{parentName:"p"},'ctx.actions.declare_output("hello/world.txt")'),". It has the following attributes:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"basename")," gives back ",(0,i.mdx)("inlineCode",{parentName:"li"},"world.txt")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"extension")," gives back ",(0,i.mdx)("inlineCode",{parentName:"li"},".txt")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"is_source")," - ",(0,i.mdx)("inlineCode",{parentName:"li"},"True")," if the artifact is a source, otherwise ",(0,i.mdx)("inlineCode",{parentName:"li"},"False"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"owner")," gives back a ",(0,i.mdx)("inlineCode",{parentName:"li"},"label")," representing the rule that created it (if it is a build output)  or ",(0,i.mdx)("inlineCode",{parentName:"li"},"None")," (if it is a source)."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"as_output()")," gives a value suitable for setting as an output to ",(0,i.mdx)("inlineCode",{parentName:"li"},"ctx.actions.run"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"short_path")," gives back ",(0,i.mdx)("inlineCode",{parentName:"li"},"hello/world.txt"))),(0,i.mdx)("h3",{id:"projected-artifacts"},"Projected artifacts"),(0,i.mdx)("p",null,"Artifacts can be ",(0,i.mdx)("em",{parentName:"p"},"projected")," via the ",(0,i.mdx)("inlineCode",{parentName:"p"},"project()")," method. Projecting an artifact yields a path within it."),(0,i.mdx)("p",null,"For example, if artifact ",(0,i.mdx)("inlineCode",{parentName:"p"},"foo")," is a directory containing a file ",(0,i.mdx)("inlineCode",{parentName:"p"},"bar"),", then ",(0,i.mdx)("inlineCode",{parentName:"p"},'foo.project("bar")')," yields the file ",(0,i.mdx)("inlineCode",{parentName:"p"},"bar"),"."),(0,i.mdx)("p",null,"It is possible for projected artifacts to hide the prefix in order to have the short name of the resulting artifact only contain the projected path, by passing ",(0,i.mdx)("inlineCode",{parentName:"p"},"hide_prefix = True")," to ",(0,i.mdx)("inlineCode",{parentName:"p"},"project()"),"."))}s.isMDXComponent=!0}}]);
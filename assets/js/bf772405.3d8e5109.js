"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6259],{3905:(e,t,r)=>{r.r(t),r.d(t,{MDXContext:()=>c,MDXProvider:()=>p,mdx:()=>g,useMDXComponents:()=>u,withMDXComponents:()=>d});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},i.apply(this,arguments)}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),d=function(e){return function(t){var r=u(t.components);return n.createElement(e,i({},t,{components:r}))}},u=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},p=function(e){var t=u(e.components);return n.createElement(c.Provider,{value:t},e.children)},h="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,a=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(r),p=o,h=d["".concat(a,".").concat(p)]||d[p]||f[p]||i;return r?n.createElement(h,s(s({ref:t},c),{},{components:r})):n.createElement(h,s({ref:t},c))}));function g(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,a=new Array(i);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=r[c];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},50594:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=r(87462),o=(r(67294),r(3905));const i={},a="Digest Kinds",s={unversionedId:"rfcs/drafts/digest-kinds",id:"rfcs/drafts/digest-kinds",title:"Digest Kinds",description:"Use cases:",source:"@site/../docs/rfcs/drafts/digest-kinds.md",sourceDirName:"rfcs/drafts",slug:"/rfcs/drafts/digest-kinds",permalink:"/docs/rfcs/drafts/digest-kinds",draft:!1,tags:[],version:"current",frontMatter:{}},l={},c=[{value:"Use cases:",id:"use-cases",level:2},{value:"Proposed plan",id:"proposed-plan",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Hashes received from RE",id:"hashes-received-from-re",level:3},{value:"Hashes of files",id:"hashes-of-files",level:3},{value:"Hashes of directories",id:"hashes-of-directories",level:3}],d={toc:c};function u(e){let{components:t,...r}=e;return(0,o.mdx)("wrapper",(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("h1",{id:"digest-kinds"},"Digest Kinds"),(0,o.mdx)("h2",{id:"use-cases"},"Use cases:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Buck2 needs to support more than just SHA1 for open-sourcing, since publicly available RE providers use SHA256."),(0,o.mdx)("li",{parentName:"ul"},"Internally, we want to migrate to (potentially keyed) Blake3, and there will be a transition period where we need to support both Blake3 and SHA1.")),(0,o.mdx)("h2",{id:"proposed-plan"},"Proposed plan"),(0,o.mdx)("p",null,"Make all the ways in which Buck2 ",(0,o.mdx)("em",{parentName:"p"},"ingests")," digests either configurable or explicit about the type of digest they expect."),(0,o.mdx)("p",null,"Internally, we may keep track of digest types for debugging purposes, but we will never compute more than one digest. It follows that we won't expose configuration for the digests we ",(0,o.mdx)("em",{parentName:"p"},"output")," (namely: to use on RE): if we only have one digest for each blob, making it configurable has no utility since you never have a choice about the hash to use."),(0,o.mdx)("h2",{id:"implementation"},"Implementation"),(0,o.mdx)("h3",{id:"hashes-received-from-re"},"Hashes received from RE"),(0,o.mdx)("p",null,"For interactions with RE, we'll expose two configurations (this can be on the CommandExecutorConfig):"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Preferred hash to use when Buck2 is doing the hashing (e.g. hashing directories)."),(0,o.mdx)("li",{parentName:"ul"},"Accepted hashes.")),(0,o.mdx)("p",null,"We'll use the format of the digests we receive from RE (in particular their size) to infer what algorithm they used (remember: the RE API provides no way of knowing the format of a digest, it's just a string)."),(0,o.mdx)("h3",{id:"hashes-of-files"},"Hashes of files"),(0,o.mdx)("p",null,"We'll expose the hash to use via a buckconfig. Our things-that-produce-hashes-of-files should either use the config to choose how they hash, or fail if they cannot provide the right hash format (e.g. that'll be true of Eden I/O)."),(0,o.mdx)("h3",{id:"hashes-of-directories"},"Hashes of directories"),(0,o.mdx)("p",null,"This one gets a little tricky. Our directories currently have an implementation of fingerprinting that receives only the directory as input, so some refactoring is in order."),(0,o.mdx)("p",null,"We have two options:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Pick the hashing algorithm based on the contents of the directory (pick one that's already used). Dealing with empty directories is a bit annoying."),(0,o.mdx)("li",{parentName:"ul"},"Refactor the directory implementation and have directories parameterized over their fingerprints, not their hasher.")),(0,o.mdx)("p",null,"The first one is easier but has the downside of not working with keyed Blake3 (because you don't have a way to bring in the key), so I'm aiming for the second implementation for now."))}u.isMDXComponent=!0}}]);
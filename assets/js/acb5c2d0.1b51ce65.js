"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4500],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>d,MDXProvider:()=>x,mdx:()=>h,useMDXComponents:()=>c,withMDXComponents:()=>p});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var d=a.createContext({}),p=function(e){return function(t){var n=c(t.components);return a.createElement(e,r({},t,{components:n}))}},c=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},x=function(e){var t=c(e.components);return a.createElement(d.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},b=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),x=l,u=p["".concat(i,".").concat(x)]||p[x]||m[x]||r;return n?a.createElement(u,o(o({ref:t},d),{},{components:n})):a.createElement(u,o({ref:t},d))}));function h(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=b;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:l,i[1]=o;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},34417:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=n(87462),l=(n(67294),n(3905));const r={id:"bxl_ctx"},i="bxl_ctx type",o={unversionedId:"api/bxl/bxl_ctx",id:"api/bxl/bxl_ctx",title:"bxl_ctx type",description:"The bxl context that the top level bxl implementation receives as parameter. This context contains all the core bxl functions to query, build, create actions, etc.",source:"@site/../docs/api/bxl/bxl_ctx.generated.md",sourceDirName:"api/bxl",slug:"/api/bxl/bxl_ctx",permalink:"/docs/api/bxl/bxl_ctx",draft:!1,tags:[],version:"current",frontMatter:{id:"bxl_ctx"},sidebar:"manualSidebar",previous:{title:"bxl_build_result type",permalink:"/docs/api/bxl/bxl_build_result"},next:{title:"bxl_output_stream type",permalink:"/docs/api/bxl/bxl_output_stream"}},s={},d=[{value:"bxl_ctx.actions_factory",id:"bxl_ctxactions_factory",level:2},{value:"bxl_ctx.analysis",id:"bxl_ctxanalysis",level:2},{value:"bxl_ctx.audit",id:"bxl_ctxaudit",level:2},{value:"bxl_ctx.build",id:"bxl_ctxbuild",level:2},{value:"bxl_ctx.bxl_actions",id:"bxl_ctxbxl_actions",level:2},{value:"bxl_ctx.cli_args",id:"bxl_ctxcli_args",level:2},{value:"bxl_ctx.configured_targets",id:"bxl_ctxconfigured_targets",level:2},{value:"bxl_ctx.cquery",id:"bxl_ctxcquery",level:2},{value:"bxl_ctx.fs",id:"bxl_ctxfs",level:2},{value:"bxl_ctx.instant_event",id:"bxl_ctxinstant_event",level:2},{value:"bxl_ctx.output",id:"bxl_ctxoutput",level:2},{value:"bxl_ctx.resolve",id:"bxl_ctxresolve",level:2},{value:"bxl_ctx.root",id:"bxl_ctxroot",level:2},{value:"bxl_ctx.unconfigured_targets",id:"bxl_ctxunconfigured_targets",level:2},{value:"bxl_ctx.uquery",id:"bxl_ctxuquery",level:2}],p={toc:d};function c(e){let{components:t,...n}=e;return(0,l.mdx)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.mdx)("h1",{id:"bxl_ctx-type"},(0,l.mdx)("inlineCode",{parentName:"h1"},"bxl_ctx")," type"),(0,l.mdx)("p",null,"The bxl context that the top level bxl implementation receives as parameter. This context contains all the core bxl functions to query, build, create actions, etc."),(0,l.mdx)("h2",{id:"bxl_ctxactions_factory"},"bxl","_","ctx.actions","_","factory"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'bxl_ctx.actions_factory: ""\n')),(0,l.mdx)("p",null,"DO NOT USE - will be deprecated soon."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxanalysis"},"bxl","_","ctx.analysis"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl_ctx.analysis(\n    labels,\n    target_platform = None,\n    skip_incompatible: bool.type = True\n)\n")),(0,l.mdx)("p",null,"Runs analysis on the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),", accepting an optional ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," which is the target platform configuration used to resolve configurations of any unconfigured target nodes, and an optional ",(0,l.mdx)("inlineCode",{parentName:"p"},"skip_incompatible")," boolean that indicates whether to skip analysis of nodes that are incompatible with the target platform. The ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," is either a string that can be parsed as a target label, or a target label."),(0,l.mdx)("p",null,"The given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is a providers expression, which is either:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"- a single string that is a `target pattern`.\n- a single target node or label, configured or unconfigured\n- a single sub target label, configured or unconfigured\n- a list of the two options above.\n")),(0,l.mdx)("p",null,"This returns either a single ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"StarlarkAnalysisResult"),"]"," if the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),' is "singular",\nor a dict keyed by sub target labels of ',"[",(0,l.mdx)("inlineCode",{parentName:"p"},"StarlarkAnalysisResult"),"]"," if the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),"\nis list-like"),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxaudit"},"bxl","_","ctx.audit"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def bxl_ctx.audit() -> "audit_ctx"\n')),(0,l.mdx)("p",null,"Returns the ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"StarlarkAuditCtx"),"]"," that holds all the audit functions."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxbuild"},"bxl","_","ctx.build"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def bxl_ctx.build(\n    spec,\n    target_platform = None,\n    *,\n    materializations: str.type = "default"\n)\n')),(0,l.mdx)("p",null,"Runs a build on the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),", accepting an optional ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," which is the target platform configuration used to resolve configurations. Note that when ",(0,l.mdx)("inlineCode",{parentName:"p"},"build()")," is called, the artifacts are materialized without needing to additionally call ",(0,l.mdx)("inlineCode",{parentName:"p"},"ensure()")," on them."),(0,l.mdx)("p",null,"The given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is a providers expression, which is either:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"- a single string that is a `target pattern`.\n- a single target node or label, configured or unconfigured\n- a single provider label, configured or unconfigured\n- a list of the two options above.\n")),(0,l.mdx)("p",null,"This returns a dict keyed by sub target labels of ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"StarlarkBuildResult"),"]"," if the\ngiven ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is list-like"),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxbxl_actions"},"bxl","_","ctx.bxl","_","actions"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def bxl_ctx.bxl_actions(\n    *,\n    exec_deps = None,\n    toolchains = None,\n    target_platform = None,\n    exec_compatible_with = None\n) -> "bxl_actions"\n')),(0,l.mdx)("p",null,"Returns the bxl actions to create and register actions for this bxl function. This will have the execution platform resolved according to the execution deps and toolchains you pass into this function. You'll be able to access the analysis action factory of the correct execution platform, toolchains, and execution deps of the corresponding configuration via this context."),(0,l.mdx)("p",null,"Actions created by bxl will not be built by default. Instead, they are marked to be built\nby ",(0,l.mdx)("inlineCode",{parentName:"p"},"ctx.output.ensure(artifact)")," on the output module of the ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"BxlContext"),"]",". Only artifacts\nmarked by ensure will be built."),(0,l.mdx)("p",null,"Sample usage:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-text"},'def _impl_write_action(ctx):\n    bxl_actions = ctx.bxl_actions()\n    output = bxl_actions.actions.write("my_output", "my_content")\n    ensured = ctx.output.ensure(output)\n    ctx.output.print(ensured)\n')),(0,l.mdx)("p",null,"There are several optional named parameters:"),(0,l.mdx)("p",null,(0,l.mdx)("inlineCode",{parentName:"p"},"exec_deps")," - These are dependencies you wish to access as executables for creating the action.\nThis is usually the same set of targets one would pass to rule's ",(0,l.mdx)("inlineCode",{parentName:"p"},"attr.exec_dep"),".\n",(0,l.mdx)("inlineCode",{parentName:"p"},"toolchains")," - The set of toolchains needed for the actions you intend to create.\n",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," - The intended target platform for your toolchains\n",(0,l.mdx)("inlineCode",{parentName:"p"},"exec_compatible_with")," - Explicit list of configuration nodes (like platforms or constraints)\nthat these actions are compatible with. This is the 'exec_compatible_with' attribute of a target."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxcli_args"},"bxl","_","ctx.cli","_","args"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'bxl_ctx.cli_args: ""\n')),(0,l.mdx)("p",null,"A struct of the command line args as declared using the ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"cli_args"),"]"," module. These command lines are resolved per the users input on the cli when invoking the bxl script."),(0,l.mdx)("p",null,"If you wish to pass in a kebab-cased arg, the arg accessed from the BXL context's ",(0,l.mdx)("inlineCode",{parentName:"p"},"cli_args"),"\nattrbute will always be in snakecase. For example, if you passed in ",(0,l.mdx)("inlineCode",{parentName:"p"},"my-arg"),", accessing it\nwithin BXL would look like ",(0,l.mdx)("inlineCode",{parentName:"p"},"ctx.cli_args.my_arg"),"."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxconfigured_targets"},"bxl","_","ctx.configured","_","targets"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl_ctx.configured_targets(labels, /, target_platform = None)\n")),(0,l.mdx)("p",null,"Gets the target nodes for the ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),", accepting an optional ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," which is the target platform configuration used to resolve configurations of any unconfigured target nodes. The ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," is either a string that can be parsed as a target label, or a target label."),(0,l.mdx)("p",null,"The given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is a ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"TargetExpr"),"]",", which is either:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"- a single string that is a `target pattern`.\n- a single target node or label, configured or unconfigured\n- a list of the two options above.\n")),(0,l.mdx)("p",null,"Note that this function does not accept ",(0,l.mdx)("inlineCode",{parentName:"p"},"Label")," (which is a configured provider label), since this\nis the label of a subtarget. You can get the underlying configured target label on the ",(0,l.mdx)("inlineCode",{parentName:"p"},"Label"),"\nusing ",(0,l.mdx)("inlineCode",{parentName:"p"},"configured_targets()")," (ex: ",(0,l.mdx)("inlineCode",{parentName:"p"},"my_label.configured_target()"),")."),(0,l.mdx)("p",null,"This returns either a single ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"StarlarkConfiguredTargetNode"),"]"," if the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),'\nis "singular", a dict keyed by target labels of ',"[",(0,l.mdx)("inlineCode",{parentName:"p"},"StarlarkConfiguredTargetNode"),"]"," if the\ngiven ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is list-like"),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxcquery"},"bxl","_","ctx.cquery"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def bxl_ctx.cquery(target_platform = None) -> "cqueryctx"\n')),(0,l.mdx)("p",null,"Returns the ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"StarlarkCQueryCtx"),"]"," that holds all the cquery functions. This function takes an optional parameter ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform"),", which is the target platform configuration used to configured any unconfigured target nodes."),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," is a target label, or a string that is a target label."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxfs"},"bxl","_","ctx.fs"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'bxl_ctx.fs: "fs"\n')),(0,l.mdx)("p",null,"Returns the ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"BxlFilesystem"),"]"," for performing a basic set of filesystem operations within bxl"),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxinstant_event"},"bxl","_","ctx.instant","_","event"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl_ctx.instant_event(*, id: str.type, metadata) -> None\n")),(0,l.mdx)("p",null,"Emits a user-defined instant event, taking in a required string id and a metadata dictionary where the keys are strings, and values are either strings, bools, or ints. The id is user-supplied, and used to identify the instant events in the event logs more easily."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxoutput"},"bxl","_","ctx.output"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'bxl_ctx.output: ""\n')),(0,l.mdx)("p",null,"Gets the output stream to the console via stdout. Items written to the output stream are considered to be the results of a bxl script, which will be displayed to stdout by buck2 even when the script is cached."),(0,l.mdx)("p",null,"Prints that are not result of the bxl should be printed via stderr via the stdlib ",(0,l.mdx)("inlineCode",{parentName:"p"},"print"),"\nand ",(0,l.mdx)("inlineCode",{parentName:"p"},"pprint"),"."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxresolve"},"bxl","_","ctx.resolve"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def bxl_ctx.resolve(action_factory: "actions", promise: "promise")\n')),(0,l.mdx)("p",null,"Awaits a promise and returns an optional value of the promise."),(0,l.mdx)("p",null,"Sample usage:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'load("//path/to/rules:rules.bzl", "my_anon_targets_rule", "my_map_function")\n\ndef _resolve_impl(ctx):\n    actions = ctx.bxl_actions().actions\n    my_attrs = {\n        "false": False,\n        "int": 42,\n        "list_string": ["a", "b", "c"],\n        "string": "a-string",\n        "true": True,\n    }\n\n    promise = actions.anon_target(my_anon_targets_rule, attrs).map(my_map_function)\n    providers_result = ctx.resolve(actions, promise) # result is `provider_callable` type, which is a collection of `provider`s\n    ctx.output.print(providers_result[0].my_field)\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxroot"},"bxl","_","ctx.root"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl_ctx.root() -> str.type\n")),(0,l.mdx)("p",null,"Returns the absolute path to the root of the repository"),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxunconfigured_targets"},"bxl","_","ctx.unconfigured","_","targets"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl_ctx.unconfigured_targets(labels)\n")),(0,l.mdx)("p",null,"Gets the unconfigured target nodes for the ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")),(0,l.mdx)("p",null,"The given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is either:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"- a single string that is a `target pattern`.\n- a single unconfigured  target node or label\n- a list of the two options above.\n")),(0,l.mdx)("p",null,"This returns either a single ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"StarlarkTargetNode"),"]"," if the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),'\nis "singular", a dict keyed by target labels of ',"[",(0,l.mdx)("inlineCode",{parentName:"p"},"StarlarkTargetNode"),"]"," if the\ngiven ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is list-like"),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_ctxuquery"},"bxl","_","ctx.uquery"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def bxl_ctx.uquery() -> "uqueryctx"\n')),(0,l.mdx)("p",null,"Returns the ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"StarlarkUQueryCtx"),"]"," that holds all uquery functions."))}c.isMDXComponent=!0}}]);
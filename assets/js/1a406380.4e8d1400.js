"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1885],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>l,MDXProvider:()=>f,mdx:()=>h,useMDXComponents:()=>p,withMDXComponents:()=>m});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},o.apply(this,arguments)}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),m=function(e){return function(n){var t=p(n.components);return a.createElement(e,o({},n,{components:t}))}},p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},f=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,l=d(e,["components","mdxType","originalType","parentName"]),m=p(t),f=i,c=m["".concat(r,".").concat(f)]||m[f]||u[f]||o;return t?a.createElement(c,s(s({ref:n},l),{},{components:t})):a.createElement(c,s({ref:n},l))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=g;var s={};for(var d in n)hasOwnProperty.call(n,d)&&(s[d]=n[d]);s.originalType=e,s[c]="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=t[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},45053:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=t(87462),i=(t(67294),t(3905));const o={},r="[RFC] Configuration Modifiers",s={unversionedId:"rfcs/drafts/cfg-modifiers/api",id:"rfcs/drafts/cfg-modifiers/api",title:"[RFC] Configuration Modifiers",description:"Target platform is Buck team's endorsed way of supporting custom build",source:"@site/../docs/rfcs/drafts/cfg-modifiers/api.md",sourceDirName:"rfcs/drafts/cfg-modifiers",slug:"/rfcs/drafts/cfg-modifiers/api",permalink:"/docs/rfcs/drafts/cfg-modifiers/api",draft:!1,tags:[],version:"current",frontMatter:{}},d={},l=[{value:"API",id:"api",level:2},{value:"1. Required Modifiers",id:"1-required-modifiers",level:3},{value:"2. (Legacy) Target platform",id:"2-legacy-target-platform",level:3},{value:"3. Per-PACKAGE modifiers",id:"3-per-package-modifiers",level:3},{value:"4. Per-Target Modifier",id:"4-per-target-modifier",level:3},{value:"<code>cfg_override</code> rule",id:"cfg_override-rule",level:3},{value:"Configuration Naming",id:"configuration-naming",level:3},{value:"Debugging modifiers",id:"debugging-modifiers",level:2},{value:"How configuration modifiers differ from transitions",id:"how-configuration-modifiers-differ-from-transitions",level:2},{value:"End Goal",id:"end-goal",level:2}],m={toc:l};function p(e){let{components:n,...t}=e;return(0,i.mdx)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"rfc-configuration-modifiers"},"[RFC]"," Configuration Modifiers"),(0,i.mdx)("p",null,"Target platform is Buck team's endorsed way of supporting custom build\nsettings, and it's intended to replace the buckconfigs and modefiles of\nbuckconfigs widely used today. Buckconfigs are bad because they are\nglobal flags, and changing them can cause invalidation of most if not\nall of Buck's state, whereas target platforms/configurations are\nper-target build settings and allow for scalable multi-configuration\nbuilds like building in multiple settings (ex. dev and opt) concurrently\nor modifying the configuration within the dependency graph. However,\ndespite improvements to configurations in Buck2, buckconfigs continue to\nbe the predominant way of representing build settings, and they are not\nlosing popularity - almost all build settings in the repo today have\nsome sort of buckconfig toggle. This means that users often hit\ninvalidation overhead from buck2 when switching modefiles or\nbuckconfigs."),(0,i.mdx)("p",null,"When comparing buckconfigs and target platforms, the biggest usability\nproblem with target platforms is that ",(0,i.mdx)("strong",{parentName:"p"},"they do not compose well"),"."),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("em",{parentName:"p"},"Using target platforms require generating all possible permutations\nof build settings"),". As an example, say I want to customize targets\nbased on different OSes (linux, mac, or windows), sanitizers (asan,\ntsan, or nosan), and link style (static or shared). With target\nplatforms, I need to first generate all possible permutations of\nthese settings as platform targets before I can use them. For this\nexample, I would need 18 different platforms: linux-asan-static,\nlinux-asan-shared, linux-tsan-static, linux-tsan-shared, so on and so\nforth. The exponential nature of platform generation makes it\nchallenging to add a new constraint because you could double the\nnumber of platforms. Buckconfigs don't have this problem because OS,\nsanitizer, and link style can be separate buckconfigs and you do not\nhave to generate all possible combinations to use them.")),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("em",{parentName:"p"},"Setting a default target platform is complex.")," Setting a default\ntarget platform for a target requires knowing the exact set of build\nsettings needed and the exact platform corresponding to those\nsettings. Because a lot of build defaults are defined in bzl files,\nthis often ends up getting handled by a set of fairly convoluted bzl\nfiles many hundreds of lines long. For example, suppose python\nlibrary ",(0,i.mdx)("inlineCode",{parentName:"p"},"root//:foo")," prefers the default settings of mac, asan, and\nstatic. The python library macros must gather those settings at once\nand map them to the platform name ",(0,i.mdx)("inlineCode",{parentName:"p"},"mac-asan-static"),". Setting a\nbuckconfig as default is as easy as adding the buckconfig value to\n.buckconfig file or a modefile.")),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("em",{parentName:"p"},"You must specify a full target platform on the command line\nfor ",(0,i.mdx)("inlineCode",{parentName:"em"},"--target-platforms")," flag"),". Despite all the convoluted macros\nneeded to set a ",(0,i.mdx)("inlineCode",{parentName:"p"},"default_target_platform"),", they become useless when\nyou don't want the default because you have to specify a ",(0,i.mdx)("strong",{parentName:"p"},"full"),"\ntarget platform on the command line. Following the previous example,\nsuppose ",(0,i.mdx)("inlineCode",{parentName:"p"},"repo//:foo")," defaults to nosan but I want to\nbuild ",(0,i.mdx)("inlineCode",{parentName:"p"},"repo//:foo")," with asan. For target platform, I have to know\nwhat OS and link style to build ",(0,i.mdx)("inlineCode",{parentName:"p"},"//:foo")," with as well so I can\nspecify ",(0,i.mdx)("inlineCode",{parentName:"p"},"buck2 build //:foo --target-platforms=:<os>-asan-<link style>"),"\nto build ",(0,i.mdx)("inlineCode",{parentName:"p"},"//:foo"),' with asan. It\'s impossible to specify "I just want\nasan on top of the defaults" with ',(0,i.mdx)("inlineCode",{parentName:"p"},"--target-platforms"),". Buckconfigs\ndon't have this problem because they can compose on the command line\nvia the ",(0,i.mdx)("inlineCode",{parentName:"p"},"--config")," flag.")),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("em",{parentName:"p"},"Target platforms are difficult to understand."),"\nMost users can easily grasp how buckconfigs work because it's easy to\nset and read them. Very few understand how configurations work\nbecause of how complex target platform resolution is. Instead, it\nwould be much simpler if constraints like OS and sanitizers can be\nset directly on the command line, similar to how buckconfigs are set."))),(0,i.mdx)("p",null,"This RFC proposes a new configuration API that is simpler and easier to\nuse than target platforms. The API is composition-first and avoids the\nexponential permutation generation of platforms. The goal of this API is\nto enable the migration of buckconfigs to configurations and make build\nsetting easy for users to use."),(0,i.mdx)("h2",{id:"api"},"API"),(0,i.mdx)("p",null,"A configuration is a collection of constraints."),(0,i.mdx)("p",null,'In this API, every top-level target starts with an empty configuration.\nTo resolve the default target configuration, Buck will apply a list of\n"modifiers". A modifier is a modification on the existing configuration\nto obtain a new configuration.'),(0,i.mdx)("p",null,"A modifier can be applied on the command line, on a PACKAGE, or on a\ntarget. When resolving modifiers, Buck will collect all modifiers from\ncommand line, PACKAGE, and target and apply them in order until the\ntarget configuration is obtained."),(0,i.mdx)("p",null,"A modifier can be specified as a ",(0,i.mdx)("inlineCode",{parentName:"p"},"constraint_value"),", a ",(0,i.mdx)("inlineCode",{parentName:"p"},"config_setting"),",\n",(0,i.mdx)("inlineCode",{parentName:"p"},"platform"),", or a ",(0,i.mdx)("inlineCode",{parentName:"p"},"cfg_override")," target. If the modifier applied\nis a constraint value, that constraint value will be added to the\nconfiguration. Config setting and platform are both collections of\nconstraints, so if the modifier is a config setting or a platform, then\nwe loop over every constraint value and add it to the configuration\n(note that since modifiers only work with configuration and not\nbuckconfigs, using a ",(0,i.mdx)("inlineCode",{parentName:"p"},"config_setting")," with a non-empty set of\nbuckconfigs as a modifier will be an error).\n",(0,i.mdx)("inlineCode",{parentName:"p"},"cfg_override")," rule applies a transition-like function\nthat can arbitrarily insert or delete constraints\nfrom the existing configuration."),(0,i.mdx)("h3",{id:"1-required-modifiers"},"1. Required Modifiers"),(0,i.mdx)("p",null,'Every top-level target starts with an empty configuration.\nBuck first applies "required modifiers", which is a list of modifiers\nprovided by the user via the command line.\nThe required modifiers are specified as\n',(0,i.mdx)("inlineCode",{parentName:"p"},"buck2 build <target>?<modifiers separated by commas>"),",\nand the list of modifiers will be applied sequentially in that order."),(0,i.mdx)("p",null,"For example,"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"If the user requests ",(0,i.mdx)("inlineCode",{parentName:"li"},"buck2 build //foo:bar"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"repo//foo:bar")," will\nhave an empty configuration after resolving the required modifiers."),(0,i.mdx)("li",{parentName:"ul"},"If the user requests\n",(0,i.mdx)("inlineCode",{parentName:"li"},"buck2 build repo//foo:bar?config//build_mode/constraints:nosan"),",\n",(0,i.mdx)("inlineCode",{parentName:"li"},"repo//foo:bar")," will have ",(0,i.mdx)("inlineCode",{parentName:"li"},"config//build_mode/constraints:nosan"),"\nin its configuration after resolving required modifiers."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"buck2 build repo//foo:bar?config//build_mode/constraints:nosan,config//build_mode/constraints:split-dwarf"),"\nwill add nosan and split-dwarf in that order to the empty\nconfiguration."),(0,i.mdx)("li",{parentName:"ul"},"If the user requests\n",(0,i.mdx)("inlineCode",{parentName:"li"},"buck2 build repo//foo:bar?config//build_mode/constraints:nosan,config//build_mode/constraints:asan"),"\nwhere both constraint values belong to the same constraint\n",(0,i.mdx)("inlineCode",{parentName:"li"},"config//build_mode/constraints:san"),",\nthen asan will replace nosan in ",(0,i.mdx)("inlineCode",{parentName:"li"},"repo//foo:bar"),"'s configuration.")),(0,i.mdx)("p",null,"To make constraints more convenient to type, you can use Buck's\ntarget alias feature to create an alias for a constraint.\nFor example, you can add the following line to your .buckconfig"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ini"},"[alias]\n  asan = config//build_mode/constraints:asan\n  nosan = config//build_mode/constraints:nosan\n")),(0,i.mdx)("p",null,"to use ",(0,i.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar?asan")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar?nosan")," as shorthand."),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo/...?asan")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:?asan"),"\nare both valid."),(0,i.mdx)("p",null,"To specify modifiers to a list of target patterns on the command line,\nyou can use the ",(0,i.mdx)("inlineCode",{parentName:"p"},"--cfg=modifier")," flag.\nFor example, ",(0,i.mdx)("inlineCode",{parentName:"p"},"buck2 build //foo:bar //foo:baz --cfg=asan"),"\nis equivalent to ",(0,i.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar?asan //foo:baz?asan"),"."),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"--cfg")," flag can be specified multiple times to add multiple modifiers.\nFor example, ",(0,i.mdx)("inlineCode",{parentName:"p"},"buck2 build --cfg=release --cfg=windows repo//foo:bar"),"\nis equivalent to ",(0,i.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar?release,windows"),".\nThis behavior is consistent with how flags are interpreted\nin other tools, and it is the most intuitive behavior, for example,"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"buckconfig ",(0,i.mdx)("inlineCode",{parentName:"li"},"-c")," flag adds to the one set of buckconfigs"),(0,i.mdx)("li",{parentName:"ul"},"build systems like CMake have flags like ",(0,i.mdx)("inlineCode",{parentName:"li"},"-D")," that can be specified\nmultiple times, and they are all added to one set of flags.")),(0,i.mdx)("p",null,"It is prohibited to specify both ",(0,i.mdx)("inlineCode",{parentName:"p"},"--cfg")," flag and ",(0,i.mdx)("inlineCode",{parentName:"p"},"?")," in target pattern.\n",(0,i.mdx)("inlineCode",{parentName:"p"},"--cfg")," flag exists for convenience, and to specify\ncomplex configuration setups (in scripts or in CI),\nusers can always specify ",(0,i.mdx)("inlineCode",{parentName:"p"},"?"),".\nThis restriction can be lifted in the future if there is a need."),(0,i.mdx)("p",null,"When specifying a subtarget and modifier with ",(0,i.mdx)("inlineCode",{parentName:"p"},"?"),",\nsubtarget should go before modifier,\nex. ",(0,i.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar[comp-db]?asan"),"."),(0,i.mdx)("p",null,"The configuration after all required modifiers are resolved is known as\nrequired configuration, and all constraints within that configuration\nare immutable entries of the target configuration. They cannot be\nremoved or overwritten. This guarantees that the configuration a target\nends up with always include the modifiers user requested."),(0,i.mdx)("p",null,"For example, if the user requests asan on the command line, the target\nconfiguration should always end up with an asan constraint value, not a\nnosan constraint value. If a later PACKAGE or per-target modifier\nspecifies nosan as a constraint, nosan will not be added to the\nconfiguration because asan and nosan both belong to the same\nconstraint ",(0,i.mdx)("inlineCode",{parentName:"p"},"config//build_mode/constraints:sanitizer"),", and asan is a\nrequired constraint."),(0,i.mdx)("h3",{id:"2-legacy-target-platform"},"2. (Legacy) Target platform"),(0,i.mdx)("p",null,"If a target platform is specified on a target\n(either via the ",(0,i.mdx)("inlineCode",{parentName:"p"},"default_target_platform")," attribute\nor the ",(0,i.mdx)("inlineCode",{parentName:"p"},"--target-platforms")," flag), then that target platform\ngets applied as a modifier, where Buck loops over every constraint\nwithin the platform and add it to the target configuration\nunless that constraint conflicts with the required configuration."),(0,i.mdx)("p",null,"When required, PACKAGE, and target modifiers are empty,\nthe target configuration is the target platform.\nThis is designed to making the new API interop\nwith target platform resolution so that the migration\ncan be gradual."),(0,i.mdx)("h3",{id:"3-per-package-modifiers"},"3. Per-PACKAGE modifiers"),(0,i.mdx)("p",null,"Per-PACKAGE modifiers are applied after target platform is resolved."),(0,i.mdx)("p",null,"To define a per-PACKAGE modifier, you can use the\n",(0,i.mdx)("inlineCode",{parentName:"p"},"add_default_cfg(<modifier>)")," function in a PACKAGE file.\nA modifier set through ",(0,i.mdx)("inlineCode",{parentName:"p"},"add_default_cfg")," will apply to\nall targets covered by that PACKAGE."),(0,i.mdx)("p",null,"The following example adds nosan and debug to the default target\nconfigurations of all targets in ",(0,i.mdx)("inlineCode",{parentName:"p"},"repo//foo/...")," unless the required\nconfiguration already has conflicting required constraints."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},'# foo/PACKAGE\n\nadd_default_cfg("config//build_mode/constraints:nosan")\nadd_default_cfg("config//build_mode/constraints:debug")\n')),(0,i.mdx)("p",null,"In this example, debug is applied after nosan."),(0,i.mdx)("p",null,"If a sub-PACKAGE exists for a PACKAGE, that sub-PACKAGE\nwill always inherit modifiers from its parent.\nThis means that if there are multiple PACKAGE files in the path\nof a target, we apply their modifiers in order from the topmost PACKAGE."),(0,i.mdx)("p",null,"Suppose ",(0,i.mdx)("inlineCode",{parentName:"p"},"repo/PACKAGE")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"repo/foo/PACKAGE")," exist for\ntarget ",(0,i.mdx)("inlineCode",{parentName:"p"},"repo//foo:bar"),". In this case, modifiers in repo/PACKAGE apply\nfirst before modifiers in ",(0,i.mdx)("inlineCode",{parentName:"p"},"repo/foo/PACKAGE"),". PACKAGE inheritance of\nmodifiers means that project-level modifiers can be easily set for all\ntargets under a project without having to wire logic through the bzl\nwrapper of every rule type in that project."),(0,i.mdx)("h3",{id:"4-per-target-modifier"},"4. Per-Target Modifier"),(0,i.mdx)("p",null,"Per-target modifier are applied after all per-PACKAGE modifier\nare resolved."),(0,i.mdx)("p",null,"Modifiers can be set on any target through the ",(0,i.mdx)("inlineCode",{parentName:"p"},"default_cfg")," attribute.\nThe modifiers are specified as a list and will be applied\nin sequential order."),(0,i.mdx)("p",null,"For example,"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},'# repo/foo/TARGETS\n\npython_binary(\n  name = "bar",\n  # Some other attributes...\n  default_cfg = [\n    "config//build_mode/constraints:nosan",\n    "config//build_mode/constraints:debug",\n  ],\n)\n')),(0,i.mdx)("p",null,"adds nosan and debug constraints in that order to\n",(0,i.mdx)("inlineCode",{parentName:"p"},"repo//foo:bar"),"'s configuration."),(0,i.mdx)("p",null,"Once per-target modifiers are resolved, we end up\nwith a target configuration used to configure a target."),(0,i.mdx)("p",null,"Note that that target's configuration can further change after modifiers\nare resolved if there are per-rule transitions applied on the target."),(0,i.mdx)("h3",{id:"cfg_override-rule"},(0,i.mdx)("inlineCode",{parentName:"h3"},"cfg_override")," rule"),(0,i.mdx)("p",null,"A modifier can be defined as a ",(0,i.mdx)("inlineCode",{parentName:"p"},"cfg_override")," rule in addition\nto platform and constraint value. This rule applies a function\nthat takes in the existing configuration as input, changes it,\nand returns a new configuration."),(0,i.mdx)("p",null,"This allows more complex logic like adding a constraint only if\nan existing constraint exists."),(0,i.mdx)("p",null,'The following example shows a way to express "use msvc on windows\nconfiguration but clang on other OSes".'),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},'# repo/BUCK\n\ndef _msvc_if_windows_else_clang_impl(\n  # `Configuration` is an opaque object that supports methods `contains`, `get`, `insert`, and `pop` similar to a dictionary.\n  cfg: "Configuration",\n  # `Refs` holds references to dependent constraints, platforms, and modifiers.\n  refs,\n) -> "Configuration":\n  if cfg.contains(refs.windows):\n    cfg.insert(refs.msvc)\n  else:\n    cfg.insert(refs.clang)\n  return cfg\n\ncfg_override(\n  name = "msvc_if_windows_else_clang",\n  impl = _msvc_if_windows_else_clang_impl,\n  refs = {\n    "clang": "config//compiler/constraints:clang",\n    "msvc": "config//compiler/constraints:msvc",\n    "windows": "config//os/constraints:windows",\n  },\n)\n\n# repo/PACKAGE\nadd_default_cfg(":msvc_if_windows_else_clang")\n')),(0,i.mdx)("p",null,"Now a target will always have the msvc constraint added\nwhen targeting windows but the clang constraint otherwise."),(0,i.mdx)("p",null,"It's possible to make ",(0,i.mdx)("inlineCode",{parentName:"p"},"cfg_override")," significantly less verbose\nvia a lambda. For example, the above example can be rewritten as"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},'# repo/BUCK\n\ncfg_override(\n  name = "msvc_if_windows_else_clang",\n  # `cfg.set` returns a `Configuration` object.\n  impl = lambda cfg, refs: cfg.set(\n    refs.msvc if cfg.contains(refs.windows) else refs.clang\n  ),\n  refs = {\n    "clang": "config//compiler/constraints:clang",\n    "msvc": "config//compiler/constraints:msvc",\n    "windows": "config//os/constraints:windows",\n  },\n)\n')),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"cfg_override")," target can only be specified for PACKAGE\nand per-target modifiers, not required modifiers\n(this restriction can be revisited later if needed)."),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"cfg_override")," is only intended for complex cases needed\nto selectively insert constraints based on existing constraints.\nFor the majority of use cases, specifying constraints directly\nas modifiers should be sufficient."),(0,i.mdx)("p",null,"Like other types of modifiers, ",(0,i.mdx)("inlineCode",{parentName:"p"},"cfg_override")," cannot override\nrequired constraints.\nTo guarantee this, ",(0,i.mdx)("inlineCode",{parentName:"p"},"insert")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"pop")," methods of ",(0,i.mdx)("inlineCode",{parentName:"p"},"Configuration")," object\nwill be no-ops if it is trying to overwrite a required constraint."),(0,i.mdx)("p",null,"For example, in the previous example, if the user supplies a requested\nconfiguration of windows and clang, then the target configuration\nwill end up containing windows and clang, not windows and msvc."),(0,i.mdx)("p",null,"To make it clear which constraints are required\nto the ",(0,i.mdx)("inlineCode",{parentName:"p"},"cfg_override")," function, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Configuration")," object\nsupports a ",(0,i.mdx)("inlineCode",{parentName:"p"},"required_cfg")," function that returns\na ",(0,i.mdx)("inlineCode",{parentName:"p"},"RequiredConfiguration")," object holding only the required constraints.\nA ",(0,i.mdx)("inlineCode",{parentName:"p"},"RequiredConfiguration")," is immutable and supports\n",(0,i.mdx)("inlineCode",{parentName:"p"},"contains")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"get")," methods but not ",(0,i.mdx)("inlineCode",{parentName:"p"},"insert"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"set"),", or ",(0,i.mdx)("inlineCode",{parentName:"p"},"pop"),"."),(0,i.mdx)("h3",{id:"configuration-naming"},"Configuration Naming"),(0,i.mdx)("p",null,"It's important for a configuration to have a representative name\nto indicate what important constraints were used.\nThis is useful for debugging because often a build error\nis caused by a misconfiguration."),(0,i.mdx)("p",null,"To make this easy, this API adds a naming function to derive a useful\nname based on the existing configuration. The name function takes in a\nmap of constraint settings to constraint values as input and returns a\nstring for the name of the configuration. This name function will be\ndefined globally for a repo."),(0,i.mdx)("p",null,"An example is as follows."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},'# Generated configuration follows the name <os>-<sanitizer>-<toolchain>.\nKEY_CONSTRAINT_SETTINGS = [\n  "config//os/constraints:os",\n  "config//build_mode/constraints:sanitizer",\n  "config//compiler/constraints:toolchain",\n]\n\ndef _name(\n  # Keys and values in `constraints_map` are fully qualified target label strings.\n  constraint_map,   # {str.type: str.type}\n) -> str.type:\n  name_builder = []\n  for constraint_setting in KEY_CONSTRAINT_SETTINGS:\n    constraint_value = constraint_map.get(constraint_setting)\n    if constraint_value is not None:\n      # Get the target name from full target label and add it to the generated name.\n      name_builder.append(constraint_value.split(":")[-1])\n\n  return "-".join(name_builder)\n')),(0,i.mdx)("h2",{id:"debugging-modifiers"},"Debugging modifiers"),(0,i.mdx)("p",null,"Because many layers of modifiers can be applied before obtaining\na final configuration, it is important that modifiers are easy\nto debug for integrators. To show what modifiers are applied,\nwe can add a ",(0,i.mdx)("inlineCode",{parentName:"p"},"buck.modifiers")," special attribute to every target\nthat keeps track of all the required modifiers, legacy target platform,\nper-PACKAGE modifiers and per-target modifiers a target goes through\nin order. We can also add a ",(0,i.mdx)("inlineCode",{parentName:"p"},"buck2 audit cfg-modifiers <TARGET>"),"\ncommand to show the configuration change after each modifier\nis applied as well as which PACKAGE/BUCK/TARGETS file\neach modifier is added."),(0,i.mdx)("h2",{id:"how-configuration-modifiers-differ-from-transitions"},"How configuration modifiers differ from transitions"),(0,i.mdx)("p",null,"Modifiers are largely inspired by configuration transitions,\nand there are a high amount of similarities in particular between\nthe ",(0,i.mdx)("inlineCode",{parentName:"p"},"cfg_override")," rule and the transition rule."),(0,i.mdx)("p",null,"The major differences are:"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"A transition can change the configuration of a target when depending\non a target, but a modifier can only change the configuration of a\ntop-level target. In other words, if you have target A that depends\non target B and you request a build of A, then A's target\nconfiguration would be resolved via modifiers and propagated down to\nB, but dep B would not do its own modifier resolution"),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("inlineCode",{parentName:"li"},"cfg_override"),' functions see an opaque "Configuration" object, so it\ncannot know every single constraint used in the configuration.\nTransition functions can iterate and read every constraint in the\nconfiguration. Transitions can use logic like "throw away the old\nconfiguration entirely and use a new configuration" (which is what\nfat platform transition currently does) whereas an override cannot.'),(0,i.mdx)("li",{parentName:"ol"},"Transitions can accept an ",(0,i.mdx)("inlineCode",{parentName:"li"},"attrs")," parameter from the attributes\nof the target if necessary whereas ",(0,i.mdx)("inlineCode",{parentName:"li"},"cfg_override")," does not\n(if necessary, this can be revisited)."),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("inlineCode",{parentName:"li"},"cfg_override")," is specified as a target and transition is not.")),(0,i.mdx)("p",null,"Ideally, we should unify all the API differences between ",(0,i.mdx)("inlineCode",{parentName:"p"},"cfg_override"),"\nand ",(0,i.mdx)("inlineCode",{parentName:"p"},"transition")," and use ",(0,i.mdx)("inlineCode",{parentName:"p"},"transition")," directly instead,\nbut that's out of the scope of this RFC for now."),(0,i.mdx)("p",null,"They have different use cases. For example,"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("em",{parentName:"li"},"Python version")," should be modeled as a transition and not modifier.\nSuppose we have ",(0,i.mdx)("inlineCode",{parentName:"li"},"python_binary")," A nested as a resource of\nanother ",(0,i.mdx)("inlineCode",{parentName:"li"},"python_binary")," B. A should not inherit the python version\nfrom B, so a transition is needed to change A's python version\nwhen depended on by B."),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("em",{parentName:"li"},"Library target")," should use modifiers and not transitions.\nA C++ library target should always inherit the configuration\nof its parent C++ binary when it is used as a dep,\nbut a top-level C++ library target can still have its configuration\nchanged via modifiers when requested from command line.")),(0,i.mdx)("h2",{id:"end-goal"},"End Goal"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"No more ",(0,i.mdx)("inlineCode",{parentName:"p"},"default_target_platform"),".")),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"No more ",(0,i.mdx)("inlineCode",{parentName:"p"},"--target-platforms")," flag.")),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"There shouldn't be a need to define ",(0,i.mdx)("inlineCode",{parentName:"p"},"platform")," targets\noutside of exec platforms.")),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"Most use cases of ",(0,i.mdx)("inlineCode",{parentName:"p"},"read_config")," are killed.\nBuckconfigs should be reserved for buck2 core features.")),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"Most build settings should only use configurations."))))}p.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8312],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>c,MDXProvider:()=>p,mdx:()=>f,useMDXComponents:()=>u,withMDXComponents:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),d=function(e){return function(t){var n=u(t.components);return a.createElement(e,i({},t,{components:n}))}},u=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(c.Provider,{value:t},e.children)},h="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(n),p=r,h=d["".concat(o,".").concat(p)]||d[p]||m[p]||i;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},596:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const i={},o="Buck Extension Language (BXL)",s={unversionedId:"rfcs/bxl",id:"rfcs/bxl",title:"Buck Extension Language (BXL)",description:"Buck2 will allow more complex introspection and interaction with its graphs via the bxl feature.",source:"@site/../docs/rfcs/bxl.md",sourceDirName:"rfcs",slug:"/rfcs/bxl",permalink:"/docs/rfcs/bxl",draft:!1,tags:[],version:"current",frontMatter:{}},l={},c=[{value:"Use Cases",id:"use-cases",level:2},{value:"Cpp LSP",id:"cpp-lsp",level:3},{value:"Android LSP",id:"android-lsp",level:3},{value:"iOS Project",id:"ios-project",level:3},{value:"Rust LSP",id:"rust-lsp",level:3},{value:"Visual Studio Project (vsgo)",id:"visual-studio-project-vsgo",level:3},{value:"Goals",id:"goals",level:2},{value:"API",id:"api",level:2},{value:"Defining a bxl function",id:"defining-a-bxl-function",level:3},{value:"Accessing target nodes",id:"accessing-target-nodes",level:3},{value:"Inspect providers",id:"inspect-providers",level:3},{value:"Actions",id:"actions",level:3},{value:"What is cached?",id:"what-is-cached",level:3},{value:"Inter-bxl caching?",id:"inter-bxl-caching",level:3}],d=(u="FbInternalOnly",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.mdx)("div",e)});var u;const p={toc:c};function h(e){let{components:t,...n}=e;return(0,r.mdx)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("h1",{id:"buck-extension-language-bxl"},"Buck Extension Language (BXL)"),(0,r.mdx)("p",null,"Buck2 will allow more complex introspection and interaction with its graphs via the ",(0,r.mdx)("inlineCode",{parentName:"p"},"bxl")," feature.\nBXL will be a starlark script that allows integrators to interact with ",(0,r.mdx)("inlineCode",{parentName:"p"},"buck")," commands like\nbuild and query within starlark, creating a sequence of operations that introspect, build,\nand extend the build graph."),(0,r.mdx)(d,{mdxType:"FbInternalOnly"},(0,r.mdx)("p",null,(0,r.mdx)("a",{parentName:"p",href:"https://fb.workplace.com/groups/buck2prototyping/permalink/2404233936540759/"},"https://fb.workplace.com/groups/buck2prototyping/permalink/2404233936540759/"),".")),(0,r.mdx)("p",null,"These are essentially custom buck operations, defined in Starlark,\nthat still follow the constraints of Buck2, which will enable\nthe same level of incrementality and caching as native buck2 operations. Furthermore, bxl will have subscriptions enabled in the future, where based on the incrementality tracking, buck2 can provide \u201cupdated\u201d bxl executions when its known that its dependencies change, and even when generated sources need to be regenerated."),(0,r.mdx)("p",null,"The following proposes a basic set of bxl api and building blocks\nthat are targeted at solving key issues for IDE integration."),(0,r.mdx)("h2",{id:"use-cases"},"Use Cases"),(0,r.mdx)("h3",{id:"cpp-lsp"},"Cpp LSP"),(0,r.mdx)(d,{mdxType:"FbInternalOnly"},(0,r.mdx)("p",null,"I\u2019ve previously defined some proposed integrations\n",(0,r.mdx)("a",{parentName:"p",href:"https://docs.google.com/document/d/1jyehtuQ236rtwq2yyLnLmsIgBOctuAm9eoqx95TCO4I/edit"},"here"),".")),(0,r.mdx)("p",null,"Lsp prefers to have a single buck command that given a file,\nreturns the corresponding compilation database. This requires a single command, i.e a bxl,\nthat accepts a file as input, performs ",(0,r.mdx)("inlineCode",{parentName:"p"},"owners")," queries,\nand uses the owning target plus the desired file to get the clang flags,\nand then writes it to disk in comp db format.\nIt\u2019s possible to write the same features using buck calls to cquery,\nand build using subtargets to generate compilation database per file.\nHowever, this requires lsp owners to maintain code in several locations and languages,\nand parse and reserialize data.\nIt also does not provide the same incrementality and subscription\nupdate features of the resulting comp db that writing this in bxl would have.\nFurthermore, we may explore the idea of trimming the compilation command\nto only dependencies required per the file requested.\nBxl actions provides a straightforward api for adding this when writing\nthe actual comp db file."),(0,r.mdx)("h3",{id:"android-lsp"},"Android LSP"),(0,r.mdx)("p",null,"Android project requires traversing the target graph to find and java libraries,\ngrouping and converting them between modules or project libraries\ndepending on the number of references, and restructuring the graph as directory based.\nAndroid LSP is able to take advantage of subscriptions in the future when available,\nallowing developers to keep their IDE up-to-date automatically without needing\nto manually regenerate the project."),(0,r.mdx)("p",null,"With bxl, the graph traversals can be written in starlark,\nallowing propagation of information down the graph,\naccessing targets\u2019 attributes to analyze dependencies,\nand access providers for artifacts and action information needed to output the project file.\nProject generation also performs directory listings\nthat buck2\u2019s dice already performs and caches (I think, need to confirm).\nBxl poses the interesting possibility that we can expose a limited set of IO operations\nthat are tracked by dice so bxl can access the same cached file operations as rest of buck2.\nAndroid project generation currently doesn\u2019t write project files to buck-out,\nwhich prevents it from using buck2 actions. It will have to rely on an external script\nto process the graph information printed by buck and write the actual project files.\nIf it moves to ",(0,r.mdx)("inlineCode",{parentName:"p"},"buck-out")," based, then it can take advantage of creating actions directly\nusing the graph information processed, and potentially take advantage of incremental actions api\nto avoid writing the entire graph on each subsequent update."),(0,r.mdx)("h3",{id:"ios-project"},"iOS Project"),(0,r.mdx)("p",null,"iOS is currently being implemented as a series of queries that are aggregated\nby an external python script, that then invokes builds of subtargets.\nThe same can be achieved in bxl, but with the entire sequence being cacheable\nand subscribable so that when the graph is updated, or even when generated files\nneed updating, buck2 can automatically push the updates.\nHowever, it is uncertain whether xcode itself can make use of push updates."),(0,r.mdx)(d,{mdxType:"FbInternalOnly"},(0,r.mdx)("p",null,"In ",(0,r.mdx)("a",{parentName:"p",href:"https://docs.google.com/document/d/1USZ_ZYxq45DHUFF-BAYo6zS4lAHlpvNk9uM5SBL9e-w/edit?disco=AAAAQv4gLQ0"},"https://docs.google.com/document/d/1USZ_ZYxq45DHUFF-BAYo6zS4lAHlpvNk9uM5SBL9e-w/edit?disco=AAAAQv4gLQ0"),",\nit was also proposed that project generation may need information to flow down\nas part of the generation, which is only possible via bxl defining its own actions.\n(Although, there may have been a workaround per Chatura).")),(0,r.mdx)("h3",{id:"rust-lsp"},"Rust LSP"),(0,r.mdx)("p",null,"(note from dbarsky@: I\u2019m adding this at Bob\u2019s request. Can be removed as needed.)"),(0,r.mdx)("h3",{id:"visual-studio-project-vsgo"},"Visual Studio Project (vsgo)"),(0,r.mdx)("p",null,"Vsgo is a pile of python that converts buck query/buck targets output\nvia a variety of heuristics into inputs to a custom fork gyp which is then invoked\nto generate visual studio projects for a given buck target.\nHaving direct access to the internals of buck would allow us to remove\nthe heuristics and possibly even move project generation directly into bxl."),(0,r.mdx)("h2",{id:"goals"},"Goals"),(0,r.mdx)("p",null,"From the above use cases, BXL should offer a simple Starlark API\nthat allows easy introspection of the buck2 graph\nat unconfigured, configured, providers, and actions stage,\nmaintaining incremental behaviour of the BXL evaluation itself."),(0,r.mdx)("p",null,"Some minimal API should be offered to allow BXL to provide additional behaviour\nsuch as output artifacts, and print results."),(0,r.mdx)("p",null,"Most use cases from LSP desire to also propagate information via the command line\nfor these operations, so BXL should support command line arguments as inputs."),(0,r.mdx)("h2",{id:"api"},"API"),(0,r.mdx)("h3",{id:"defining-a-bxl-function"},"Defining a bxl function"),(0,r.mdx)("p",null,"There are multiple models possible. We can have each file be its own bxl,\nor have each file declare multiple bxl like rules."),(0,r.mdx)("p",null,"There are multiple advantages to allowing declaration of multiple bxls,\nsuch as grouping similar bxls in the same file, allowing them to \u201cinvoke\u201d each other.\nIt doesn\u2019t necessarily add much more complexity for the author,\nas even with one bxl per file, the author still has to have some declaration for the bxls arguments."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# sample.bxl\nfunc1 = bxl(\n   impl = my_func1,\n   args = {\n     \u201carg1\u201d: arg.list(arg.str()),\n   }\n)\n\nfunc2 = bxl(\n   ...\n)\n\n")),(0,r.mdx)("p",null,"To invoke buck2 for that bxl, we can have the command line as follows."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-shell"},"buck2 bxl sample.bxl::func1 -- --arg1 foo bar baz\n")),(0,r.mdx)("p",null,"For bxl functions to read the arguments, a similar api to rule attrs is used"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"args = ctx.args.args_for_bxl\n")),(0,r.mdx)("p",null,"Args defined like attrs when declaring the bxl function above"),(0,r.mdx)("h3",{id:"accessing-target-nodes"},"Accessing target nodes"),(0,r.mdx)("p",null,"All standard query functions will be enabled in bxl, allowing users to run query operations,\nstoring them in variables and interacting with them.\nThese allow introspection of the unconfigured targets,\nor the configured targets based on api"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'# some.bxl\ntargets = ctx.uquery(\u2018deps("//foo")\u2019)\ntargets = filter(targets, my_filter)\n\n# introspect a target\nfor target in targets:\n  ctx.print(target.attributes) # prints selects\n  # also inspect the target like below\n  ctx.print(target.label)\n\ntarget = ctx.cquery(\u201c//foo\u201d, \u201c//x86\u201d).attributes # cquery has selects resolved\n')),(0,r.mdx)("h3",{id:"inspect-providers"},"Inspect providers"),(0,r.mdx)("p",null,"When we have a configured target, bxl can request for the analysis of the rule"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"target = <some configured target>\n\nctx.analysis(target).providers # access the providers\n")),(0,r.mdx)("h3",{id:"actions"},"Actions"),(0,r.mdx)("p",null,"For IDEs, to generate compilation databases, or generate project files,\nwriting them in bxl will entail creating actions, and executing them.\nAs such, bxl will also be given the rules api to register actions,\nincluding dynamic outputs for the rule in the current bxl invocation to build artifacts\nas part of a bxl function."),(0,r.mdx)("p",null,"BXL has the ability to create actions with some constraints:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},"Action is tied to a particular target"),(0,r.mdx)("li",{parentName:"ol"},"It\u2019s output location is determined in the same pattern as regular actions defined via rules")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"targets = ctx.cquery(\u2018deps(\u201c//foo:rule\u201d)\u2019)\n\nfor t in targets:\n  action_ctx = ctx.analysis(t).actions\n  # the action context here is tied to the configured target `t`\n  # actions registered by bxl will be attached with bxl prefix key\n  action_ctx.registry.write(some_output, \u201cfoo\u201d)\n\n")),(0,r.mdx)("p",null,"BXL can also interact with the existing actions on an action via the action_ctx,\nsuch as iterating through it, analyzing its outputs, or requesting it to be ran."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"targets = deps(\u201cfoo:rule\u201d)\n\nfor t in targets:\n  action_ctx = ctx.analysis(t).actions\n  for action in action_ctx.iter():\n    if \u201cfoo/path\u201d in action.output:\n      ctx.build(action)\n")),(0,r.mdx)("h3",{id:"what-is-cached"},"What is cached?"),(0,r.mdx)("p",null,"All computations requested by a bxl function will be treated as inputs.\nSo if a bxl function calls uquery, then uses the result to do a cquery, and then a build,\nif buck2 detects that any of the recorded calls to uquery, cquery, and build changes,\nthe entire bxl will be reran, with no early cutoff.\nThe computations itself will still be cached via DICE,\nso no major performance issues are expected.\nHowever, in the event that a bxl function is computationally heavy,\nthe recommendation would be to move that to an action,\nor split up the bxl and use inter-bxl caching described below."),(0,r.mdx)("h3",{id:"inter-bxl-caching"},"Inter-bxl caching?"),(0,r.mdx)("p",null,"Different bxl can be cacheable between each other if structured as \u201coutputs\u201d/artifacts.\nThis is essentially the same behaviour as a bxl requesting ",(0,r.mdx)("inlineCode",{parentName:"p"},"ctx.build"),", which is cached.\nSince we have those as hashes on RE, we can track properly and not require\nstoring the values in dice."),(0,r.mdx)("p",null,"i.e."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"# caching_sample.bxl\nfunc1 = bxl(\n   impl = my_func1,\n   args = {\n     \u201carg1\u201d: arg.list(arg.str()),\n   }\n)\n\nmy_func1(ctx):\n  \u2026\n  # do various stuff that might change a lot, but the final result\n  # doesn\u2019t change much\n  ctx.return(some_artifact)\n\nfunc2 = bxl(\n  impl = my_func2,\n  ...\n)\n\nmy_func2(ctx):\n  artifact = ctx.bxl(\u201c:func1\u201d)\n  # now read artifact value\n  # everything below will only be reran if the artifact content changes\n  \u2026\n  # do some expensive stuff\n")))}h.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6742],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>p,MDXProvider:()=>u,mdx:()=>x,useMDXComponents:()=>s,withMDXComponents:()=>d});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function m(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),d=function(e){return function(t){var n=s(t.components);return a.createElement(e,r({},t,{components:n}))}},s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},c="mdxType",y={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=m(e,["components","mdxType","originalType","parentName"]),d=s(n),u=i,c=d["".concat(l,".").concat(u)]||d[u]||y[u]||r;return n?a.createElement(c,o(o({ref:t},p),{},{components:n})):a.createElement(c,o({ref:t},p))}));function x(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=h;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},99238:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>l,default:()=>s,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={id:"types"},l="Starlark Types",o={unversionedId:"developers/starlark/types",id:"developers/starlark/types",title:"Starlark Types",description:"The Starlark 'types' extension is highly experimental and likely to be modified in the future.",source:"@site/../docs/developers/starlark/types.generated.md",sourceDirName:"developers/starlark",slug:"/developers/starlark/types",permalink:"/docs/developers/starlark/types",draft:!1,tags:[],version:"current",frontMatter:{id:"types"},sidebar:"manualSidebar",previous:{title:"Starlark Language Specification",permalink:"/docs/developers/starlark/spec"},next:{title:"Value Representation",permalink:"/docs/developers/starlark/values"}},m={},p=[{value:"What does a type mean?",id:"what-does-a-type-mean",level:2},{value:"Record types",id:"record-types",level:2},{value:"Enum types",id:"enum-types",level:2}],d={toc:p};function s(e){let{components:t,...n}=e;return(0,i.mdx)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"starlark-types"},"Starlark Types"),(0,i.mdx)("p",null,"The Starlark 'types' extension is highly experimental and likely to be modified in the future."),(0,i.mdx)("p",null,"Types can be added to function arguments, or function return types."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},"def fib(i: int.type) -> int.type:\n    ...\n")),(0,i.mdx)("p",null,"These types are checked ",(0,i.mdx)("em",{parentName:"p"},"at runtime"),". Currently, there is no static checking or linting for them."),(0,i.mdx)("p",null,"The rest of this document lays out what types mean and what type-supporting objects have been written using them."),(0,i.mdx)("h2",{id:"what-does-a-type-mean"},"What does a type mean?"),(0,i.mdx)("p",null,"A type is just an arbitrary expression that evaluates to a value; that value is then treated as a type, which is matched against values:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"When ",(0,i.mdx)("inlineCode",{parentName:"li"},"fib(3)")," is called, the ",(0,i.mdx)("em",{parentName:"li"},"value")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"3")," is passed to ",(0,i.mdx)("inlineCode",{parentName:"li"},"fib")," as parameter ",(0,i.mdx)("inlineCode",{parentName:"li"},"i"),"."),(0,i.mdx)("li",{parentName:"ul"},"When the execution of ",(0,i.mdx)("inlineCode",{parentName:"li"},"fib")," is started, the ",(0,i.mdx)("em",{parentName:"li"},"expression")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"int.type")," is evaluated to ",(0,i.mdx)("inlineCode",{parentName:"li"},'"int"'),"."),(0,i.mdx)("li",{parentName:"ul"},"A check is then made that the value ",(0,i.mdx)("inlineCode",{parentName:"li"},"3")," matches the type represented by ",(0,i.mdx)("inlineCode",{parentName:"li"},'"int"'),".")),(0,i.mdx)("p",null,"If the value doesn't match, it is a runtime error. Similarly, on ",(0,i.mdx)("inlineCode",{parentName:"p"},"return")," statements, or the end of the function, a check is made that result type matches ",(0,i.mdx)("inlineCode",{parentName:"p"},"int.type"),"."),(0,i.mdx)("p",null,"Types match using the following rules:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},'""')," means anything."),(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},'"foo"')," means any value of type ",(0,i.mdx)("inlineCode",{parentName:"li"},"foo"),", where the type of ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")," is computed by doing ",(0,i.mdx)("inlineCode",{parentName:"li"},"type(x)"),". That means that ",(0,i.mdx)("inlineCode",{parentName:"li"},'"int"'),", ",(0,i.mdx)("inlineCode",{parentName:"li"},'"bool"')," and ",(0,i.mdx)("inlineCode",{parentName:"li"},'"string"')," are common types."),(0,i.mdx)("li",{parentName:"ul"},"Most constructor functions provide a ",(0,i.mdx)("inlineCode",{parentName:"li"},".type")," property to obtain the type they produce, allowing ",(0,i.mdx)("inlineCode",{parentName:"li"},"int.type"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"bool.type")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"str.type")," etc."),(0,i.mdx)("li",{parentName:"ul"},"Any string starting with an underscore ",(0,i.mdx)("inlineCode",{parentName:"li"},"_")," (for example, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"_a"')," means anything) but the name is often used as a hint to say where types go in polymorphic functions."),(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},"None")," means the result must be ",(0,i.mdx)("inlineCode",{parentName:"li"},"None"),"."),(0,i.mdx)("li",{parentName:"ul"},"The singleton list ",(0,i.mdx)("inlineCode",{parentName:"li"},"[t]")," means a list where each element must be of type ",(0,i.mdx)("inlineCode",{parentName:"li"},"t"),". If you want a list of any types, use ",(0,i.mdx)("inlineCode",{parentName:"li"},'[""]'),"."),(0,i.mdx)("li",{parentName:"ul"},"Multiple element lists ",(0,i.mdx)("inlineCode",{parentName:"li"},"[t1,t2]")," are OR types, where the value must be either type ",(0,i.mdx)("inlineCode",{parentName:"li"},"t1")," OR type ",(0,i.mdx)("inlineCode",{parentName:"li"},"t2"),"."),(0,i.mdx)("li",{parentName:"ul"},"A tuple ",(0,i.mdx)("inlineCode",{parentName:"li"},"(t1, t2, t3)")," matches tuples of the same length (3 in this case), where each element of the value must match the corresponding element of the tuple."),(0,i.mdx)("li",{parentName:"ul"},"A singleton dictionary ",(0,i.mdx)("inlineCode",{parentName:"li"},"{k: v}")," means a dictionary where all the keys have type ",(0,i.mdx)("inlineCode",{parentName:"li"},"k"),", and all the values have type ",(0,i.mdx)("inlineCode",{parentName:"li"},"v"),"."),(0,i.mdx)("li",{parentName:"ul"},"It is possible to define functions that return types. For example, ",(0,i.mdx)("inlineCode",{parentName:"li"},"def StrDict(t): return {str.type: t}")," would mean ",(0,i.mdx)("inlineCode",{parentName:"li"},"StrDict(int.type)")," was a valid type.")),(0,i.mdx)("p",null,"The goals of this type system are:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Reuse the existing machinery of Starlark as much as possible, avoiding inventing a special class of type values. As a consequence, any optimisations for values like string/list are reused."),(0,i.mdx)("li",{parentName:"ul"},"Provide a pleasing syntax."),(0,i.mdx)("li",{parentName:"ul"},"Some degree of compatibility with Python, which allows types as expressions in the same places Buck2 allows them (but with different meaning and different checking)."),(0,i.mdx)("li",{parentName:"ul"},"And finally, a non-goal is to provide a complete type system capable of representing every type invariant: it's intended to be a lossy approximation.")),(0,i.mdx)("p",null,"In addition to these built-in types, records and enumerations are provided as special concepts."),(0,i.mdx)("h2",{id:"record-types"},"Record types"),(0,i.mdx)("p",null,"A ",(0,i.mdx)("inlineCode",{parentName:"p"},"record")," type represents a set of named values, each with their own type."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},"MyRecord = record(host=str.type, port=int.type)\n")),(0,i.mdx)("p",null,"This above statement defines a record ",(0,i.mdx)("inlineCode",{parentName:"p"},"MyRecord")," with 2 fields, the first named ",(0,i.mdx)("inlineCode",{parentName:"p"},"host")," that must be of type ",(0,i.mdx)("inlineCode",{parentName:"p"},"str.type"),", and the second named ",(0,i.mdx)("inlineCode",{parentName:"p"},"port")," that must be of type ",(0,i.mdx)("inlineCode",{parentName:"p"},"int.type"),"."),(0,i.mdx)("p",null,"Now ",(0,i.mdx)("inlineCode",{parentName:"p"},"MyRecord")," is defined, it's possible to do the following:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Create values of this type with ",(0,i.mdx)("inlineCode",{parentName:"li"},'MyRecord(host="localhost", port=80)'),". It is a runtime error if any arguments are missed, of the wrong type, or if any unexpected arguments are given."),(0,i.mdx)("li",{parentName:"ul"},"Get the type of the record suitable for a type annotation with ",(0,i.mdx)("inlineCode",{parentName:"li"},"MyRecord.type"),"."),(0,i.mdx)("li",{parentName:"ul"},"Get the fields of the record. For example, ",(0,i.mdx)("inlineCode",{parentName:"li"},'v = MyRecord(host="localhost", port=80)')," will provide ",(0,i.mdx)("inlineCode",{parentName:"li"},'v.host == "localhost"')," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"v.port == 80"),". Similarly, ",(0,i.mdx)("inlineCode",{parentName:"li"},'dir(v) == ["host", "port"]'),".")),(0,i.mdx)("p",null,"It is also possible to specify default values for parameters using the ",(0,i.mdx)("inlineCode",{parentName:"p"},"field")," function."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},"MyRecord = record(host=str.type, port=field(int.type, 80))\n")),(0,i.mdx)("p",null,"Now the ",(0,i.mdx)("inlineCode",{parentName:"p"},"port")," field can be omitted, defaulting to ",(0,i.mdx)("inlineCode",{parentName:"p"},"80")," is not present (for example, ",(0,i.mdx)("inlineCode",{parentName:"p"},'MyRecord(host="localhost").port == 80'),")."),(0,i.mdx)("p",null,"Records are stored deduplicating their field names, making them more memory efficient than dictionaries."),(0,i.mdx)("h2",{id:"enum-types"},"Enum types"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"enum")," type represents one value picked from a set of values."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},'MyEnum = enum("option1", "option2", True)\n')),(0,i.mdx)("p",null,"This statement defines an enumeration ",(0,i.mdx)("inlineCode",{parentName:"p"},"MyEnum")," that consists of the three values ",(0,i.mdx)("inlineCode",{parentName:"p"},'"option1"'),", ",(0,i.mdx)("inlineCode",{parentName:"p"},'"option2"')," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"True"),"."),(0,i.mdx)("p",null,"Now ",(0,i.mdx)("inlineCode",{parentName:"p"},"MyEnum")," is defined, it's possible to do the following:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Create values of this type with ",(0,i.mdx)("inlineCode",{parentName:"li"},'MyEnum("option2")'),". It is a runtime error if the argument is not one of the predeclared values of the enumeration."),(0,i.mdx)("li",{parentName:"ul"},"Get the type of the enum suitable for a type annotation with ",(0,i.mdx)("inlineCode",{parentName:"li"},"MyEnum.type"),"."),(0,i.mdx)("li",{parentName:"ul"},"Given a value of the enum (for example, ",(0,i.mdx)("inlineCode",{parentName:"li"},'v = MyEnum("option2")'),"), get the underlying value ",(0,i.mdx)("inlineCode",{parentName:"li"},'v.value == "option2"')," or the index in the enumeration ",(0,i.mdx)("inlineCode",{parentName:"li"},"v.index = 1"),"."),(0,i.mdx)("li",{parentName:"ul"},"Get a list of the values that make up the array with ",(0,i.mdx)("inlineCode",{parentName:"li"},'MyEnum.values() == ["option1", "option2", True]'),"."),(0,i.mdx)("li",{parentName:"ul"},"Treat ",(0,i.mdx)("inlineCode",{parentName:"li"},"MyEnum")," a bit like an array, with ",(0,i.mdx)("inlineCode",{parentName:"li"},"len(MyEnum) == 3"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},'MyEnum[1] == MyEnum("option2")')," and iteration over enums ",(0,i.mdx)("inlineCode",{parentName:"li"},'[x.value for x in MyEnum] == ["option1", "option2", True]'),".")),(0,i.mdx)("p",null,"Enumeration types store each value once, which are then efficiently referenced by enumeration values."))}s.isMDXComponent=!0}}]);
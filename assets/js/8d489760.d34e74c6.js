"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3631],{3905:(e,n,a)=>{a.r(n),a.d(n,{MDXContext:()=>d,MDXProvider:()=>u,mdx:()=>f,useMDXComponents:()=>p,withMDXComponents:()=>s});var t=a(67294);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e},o.apply(this,arguments)}function l(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function r(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?l(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function m(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var d=t.createContext({}),s=function(e){return function(n){var a=p(n.components);return t.createElement(e,o({},n,{components:a}))}},p=function(e){var n=t.useContext(d),a=n;return e&&(a="function"==typeof e?e(n):r(r({},n),e)),a},u=function(e){var n=p(e.components);return t.createElement(d.Provider,{value:n},e.children)},c="mdxType",x={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=m(e,["components","mdxType","originalType","parentName"]),s=p(a),u=i,c=s["".concat(l,".").concat(u)]||s[u]||x[u]||o;return a?t.createElement(c,r(r({ref:n},d),{},{components:a})):t.createElement(c,r({ref:n},d))}));function f(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=a.length,l=new Array(o);l[0]=h;var r={};for(var m in n)hasOwnProperty.call(n,m)&&(r[m]=n[m]);r.originalType=e,r[c]="string"==typeof e?e:i,l[1]=r;for(var d=2;d<o;d++)l[d]=a[d];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}h.displayName="MDXCreateElement"},55284:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>m,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var t=a(87462),i=(a(67294),a(3905));const o={id:"environment"},l="Environments",r={unversionedId:"developers/starlark/environment",id:"developers/starlark/environment",title:"Environments",description:"Some of the information within this page is outdated. However, the explanation of the problem, and thought process behind it, remains useful. The storage of values is similar but implemented using different types.",source:"@site/../docs/developers/starlark/environment.generated.md",sourceDirName:"developers/starlark",slug:"/developers/starlark/environment",permalink:"/docs/developers/starlark/environment",draft:!1,tags:[],version:"current",frontMatter:{id:"environment"},sidebar:"manualSidebar",previous:{title:"Finding Commands That Buck2 Ran",permalink:"/docs/developers/what-ran"},next:{title:"A Moving Garbage Collector",permalink:"/docs/developers/starlark/gc"}},m={},d=[{value:"Global Environment",id:"global-environment",level:2},{value:"Slots",id:"slots",level:2},{value:"Module Environment",id:"module-environment",level:2},{value:"Function Environment",id:"function-environment",level:2},{value:"Optimisations",id:"optimisations",level:2}],s={toc:d};function p(e){let{components:n,...a}=e;return(0,i.mdx)("wrapper",(0,t.Z)({},s,a,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"environments"},"Environments"),(0,i.mdx)("admonition",{type:"warning"},(0,i.mdx)("p",{parentName:"admonition"},"Some of the information within this page is outdated. However, the explanation of the problem, and thought process behind it, remains useful. The storage of values is similar but implemented using different types.")),(0,i.mdx)("p",null,"Starlark (with a nested ",(0,i.mdx)("inlineCode",{parentName:"p"},"def"),") has a series of environments that may be active during an evaluation, as illustrated in the following example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},"x = []\ndef foo():\n    y = True\n    def bar():\n        z = 1\n        list.append(x, 1)\n")),(0,i.mdx)("p",null,"The above example features the following environments:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Global environment - defining things like ",(0,i.mdx)("inlineCode",{parentName:"li"},"list.append")),(0,i.mdx)("li",{parentName:"ul"},"Module environment - defining ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")),(0,i.mdx)("li",{parentName:"ul"},"Environment of ",(0,i.mdx)("inlineCode",{parentName:"li"},"foo")," - defining ",(0,i.mdx)("inlineCode",{parentName:"li"},"y")),(0,i.mdx)("li",{parentName:"ul"},"Environment of ",(0,i.mdx)("inlineCode",{parentName:"li"},"bar")," - defining ",(0,i.mdx)("inlineCode",{parentName:"li"},"z"))),(0,i.mdx)("p",null,"A scope can ",(0,i.mdx)("em",{parentName:"p"},"access")," variables defined above it, and often ",(0,i.mdx)("em",{parentName:"p"},"mutate")," them, but not ",(0,i.mdx)("em",{parentName:"p"},"assign")," them."),(0,i.mdx)("p",null,"To unpack that:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"From the statements inside ",(0,i.mdx)("inlineCode",{parentName:"li"},"bar"),", you can access ",(0,i.mdx)("inlineCode",{parentName:"li"},"list.append"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"x"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"y"),", and ",(0,i.mdx)("inlineCode",{parentName:"li"},"z"),"."),(0,i.mdx)("li",{parentName:"ul"},"From inside ",(0,i.mdx)("inlineCode",{parentName:"li"},"bar"),", you can mutate the variables to be accessed with statements like ",(0,i.mdx)("inlineCode",{parentName:"li"},"list.append(x, 1)")," (which may also be termed ",(0,i.mdx)("inlineCode",{parentName:"li"},"x.append(1)"),").",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"However, before this module is imported by another module, all of its exports become ",(0,i.mdx)("em",{parentName:"li"},"frozen"),", which means it isn't possible to mutate a global list, and if ",(0,i.mdx)("inlineCode",{parentName:"li"},"foo")," is called from a different module, then ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")," can't be modified."))),(0,i.mdx)("li",{parentName:"ul"},"If ",(0,i.mdx)("inlineCode",{parentName:"li"},"bar")," does ",(0,i.mdx)("inlineCode",{parentName:"li"},"x = 1")," that defines a local variable ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")," in the function ",(0,i.mdx)("inlineCode",{parentName:"li"},"bar"),", shadowing the global ",(0,i.mdx)("inlineCode",{parentName:"li"},"x"),". As a consequence, you cannot assign to variables defined in an outer scope.")),(0,i.mdx)("p",null,"Note that assignment ",(0,i.mdx)("em",{parentName:"p"},"after"),", or even ",(0,i.mdx)("em",{parentName:"p"},"in")," non-executed conditional branches, introduces a local variable."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},"x = 1\ndef f():\n    print(x)\n    if False:\n        x = 2\n")),(0,i.mdx)("p",null,"In the above code, on executing ",(0,i.mdx)("inlineCode",{parentName:"p"},"f()"),", it would complain that ",(0,i.mdx)("inlineCode",{parentName:"p"},"x")," is referenced before assignment, as the assignment ",(0,i.mdx)("inlineCode",{parentName:"p"},"x = 2")," makes ",(0,i.mdx)("inlineCode",{parentName:"p"},"x")," a local variable."),(0,i.mdx)("p",null,"The rest of this document outlines the various types of environments, how they are accessed,  and how they are updated."),(0,i.mdx)("h2",{id:"global-environment"},"Global Environment"),(0,i.mdx)("p",null,"The global environment is always frozen and consists of ",(0,i.mdx)("em",{parentName:"p"},"functions")," and ",(0,i.mdx)("em",{parentName:"p"},"type-values"),". All things in the global environment are accessed by name."),(0,i.mdx)("p",null,"Type-values are things like ",(0,i.mdx)("inlineCode",{parentName:"p"},"list.append"),", which is used when you do either ",(0,i.mdx)("inlineCode",{parentName:"p"},"list.append(xs, 1)")," or ",(0,i.mdx)("inlineCode",{parentName:"p"},"xs.append(1)"),", assuming ",(0,i.mdx)("inlineCode",{parentName:"p"},"xs")," is of type ",(0,i.mdx)("inlineCode",{parentName:"p"},"list"),". The available methods for a type can be queried (for example, ",(0,i.mdx)("inlineCode",{parentName:"p"},"dir(list)"),")."),(0,i.mdx)("p",null,"There are also global functions, such as ",(0,i.mdx)("inlineCode",{parentName:"p"},"len"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"range"),", and ",(0,i.mdx)("inlineCode",{parentName:"p"},"str"),"."),(0,i.mdx)("h2",{id:"slots"},"Slots"),(0,i.mdx)("p",null,"To optimise evaluation, all variables are accessed by integers, which are known as 'slots'. Many variables can be converted to slots statically during compilation, and those which can't have their slot looked up by name at runtime."),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"Slots")," data type is defined as:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-rust"},"enum Slots {\n    Frozen(FrozenSlots),\n    Slots(Rc<RefCell<Vec<Option<Value>>>>),\n}\n\nstruct FrozenSlots(Arc<Vec<Option<FrozenValue>>>);\n")),(0,i.mdx)("p",null,"As featured in the above code:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"A set of slots are either ",(0,i.mdx)("inlineCode",{parentName:"li"},"Frozen"),", which came from another module behind ",(0,i.mdx)("inlineCode",{parentName:"li"},"Arc")," or just normal ",(0,i.mdx)("inlineCode",{parentName:"li"},"Slots"),", which can be manipulated by the current scope (behind a ",(0,i.mdx)("inlineCode",{parentName:"li"},"Rc"),"/",(0,i.mdx)("inlineCode",{parentName:"li"},"RefCell")," for single-threaded use and mutation)."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Vec")," is accessed by the slot index."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Option")," refers to whether the slot has been assigned yet (to detect variables referenced before assignment).")),(0,i.mdx)("h2",{id:"module-environment"},"Module Environment"),(0,i.mdx)("p",null,"The module environment is where the module executes, namely where ",(0,i.mdx)("inlineCode",{parentName:"p"},"x")," is defined above. The module environment can have values added in the following standards-conforming ways:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Assignment statements (such as ",(0,i.mdx)("inlineCode",{parentName:"li"},"x = 1")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"x += 1"),")."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"For")," loops (such as the ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")," in ",(0,i.mdx)("inlineCode",{parentName:"li"},"for x in []:"),")."),(0,i.mdx)("li",{parentName:"ul"},"Via the ",(0,i.mdx)("inlineCode",{parentName:"li"},'load("a.bzl", "foo")'),", which imports ",(0,i.mdx)("inlineCode",{parentName:"li"},"foo")," frozen."),(0,i.mdx)("li",{parentName:"ul"},"Via ",(0,i.mdx)("inlineCode",{parentName:"li"},"def foo():"),", which defines ",(0,i.mdx)("inlineCode",{parentName:"li"},"foo")," in the module environment. Whether a ",(0,i.mdx)("inlineCode",{parentName:"li"},"def")," is frozen or not, when it's executed, its local variables are not frozen.")),(0,i.mdx)("p",null,"In addition, two non-standards-conforming ways of defining variables are supported:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Some modules can be injected as bindings in advance. Given a module ",(0,i.mdx)("inlineCode",{parentName:"li"},"foo")," that is injected, all the bindings of ",(0,i.mdx)("inlineCode",{parentName:"li"},"foo")," will be inserted in this module as frozen."),(0,i.mdx)("li",{parentName:"ul"},"The function ",(0,i.mdx)("inlineCode",{parentName:"li"},"load_symbols")," injects a dictionary of bindings into the module environment.")),(0,i.mdx)("p",null,"Note that a module has a fixed set of variables (from the standards-conforming ways), a pre-execution set (from the injections) and yet more variables at runtime (via ",(0,i.mdx)("inlineCode",{parentName:"p"},"load_symbols"),"). To support that structure, the mapping from name to slot index is tracked in a struct:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-rust"},"enum Names {\n    Frozen(FrozenNames),\n    Names(Rc<RefCell<HashMap<String, usize>>>),\n}\nstruct FrozenNames(Arc<HashMap<String, usize>>);\n")),(0,i.mdx)("p",null,"Each name is given an entry in the map with an increasing slot index. A name will only be assigned a slot once, reusing it thereafter. A corresponding ",(0,i.mdx)("inlineCode",{parentName:"p"},"Slots")," data type provides the values associated with those names."),(0,i.mdx)("p",null,"Importantly, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Slots")," can be extended at runtime by the ",(0,i.mdx)("inlineCode",{parentName:"p"},"load_symbols")," function. As with ",(0,i.mdx)("inlineCode",{parentName:"p"},"Slots"),", you can either share things behind an ",(0,i.mdx)("inlineCode",{parentName:"p"},"Arc")," or mutate them behind an ",(0,i.mdx)("inlineCode",{parentName:"p"},"Rc"),"/",(0,i.mdx)("inlineCode",{parentName:"p"},"RefCell"),"."),(0,i.mdx)("h2",{id:"function-environment"},"Function Environment"),(0,i.mdx)("p",null,"A function can have variables introduced via assignments, ",(0,i.mdx)("inlineCode",{parentName:"p"},"for")," loops, and parameters. No additional variables can be discovered at runtime, so all names can be erased at compile time."),(0,i.mdx)("p",null,"A function can also access variables from the functions it is statically nested within, and from the variables at the root of the module. To support this structure, at runtime we pass around the context, defined as:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-rust"},"struct Context {\n    names: Names,\n    slots: Vec<Slots>,\n}\n")),(0,i.mdx)("p",null,"The above code contains the mapping of names for the module and the slots for the module and each function."),(0,i.mdx)("p",null,"When executed, the inner-most ",(0,i.mdx)("inlineCode",{parentName:"p"},"Slots")," (at the end of ",(0,i.mdx)("inlineCode",{parentName:"p"},"slots:"),") will never be frozen, as that represents the local variables: but any other may be."),(0,i.mdx)("p",null,"When a function value is captured in a frozen module, use ",(0,i.mdx)("inlineCode",{parentName:"p"},"FrozenContext"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-rust"},"struct FrozenContext {\n    names: FrozenNames,\n    slots: Vec<FrozenSlots>,\n}\n\n## List comprehension environments\n\nA list comprehension can be defined as:\n\n```python\n[x for x in [1,2,3]]\n")),(0,i.mdx)("p",null,"In the above code:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"The statement defines a variable ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")," that is immediately initialised and shadows any other variables ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")," in scope."),(0,i.mdx)("li",{parentName:"ul"},"The variable ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")," cannot be assigned to, other than in the list comprehension, as it only lives inside the comprehension and the comprehension does not permit assignment statements (only expressions). Such names are not available at the top-level, even when defined in the root of a module.")),(0,i.mdx)("p",null,"List comprehensions are implemented by adding additional entries into the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Slots")," data type. Even when added at the root of a module, such names are not added to ",(0,i.mdx)("inlineCode",{parentName:"p"},"Names"),"."),(0,i.mdx)("h2",{id:"optimisations"},"Optimisations"),(0,i.mdx)("p",null,"There are a number of optimisations made to the scheme:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"When freezing a ",(0,i.mdx)("inlineCode",{parentName:"li"},"Names")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"Slots")," structure, it's important to only freeze a particular mutable variant once, or you duplicate memory unnecessarily. Therefore, the ",(0,i.mdx)("inlineCode",{parentName:"li"},"Slots")," to be ",(0,i.mdx)("inlineCode",{parentName:"li"},"Rc<RefCell<(_, Option<FrozenSlots>)>>")," are augmented, and, similarly, the ",(0,i.mdx)("inlineCode",{parentName:"li"},"Names"),".",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"When ",(0,i.mdx)("inlineCode",{parentName:"li"},"freeze")," is called, the original value is consumed, and the ",(0,i.mdx)("inlineCode",{parentName:"li"},"Some")," variant is added."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Note"),": it is unsafe to ever access the slots after the ",(0,i.mdx)("inlineCode",{parentName:"li"},"freeze"),"."))),(0,i.mdx)("li",{parentName:"ul"},"Programs can only assign to the inner-most ",(0,i.mdx)("inlineCode",{parentName:"li"},"Slots"),", and that slots must always be mutable. Therefore, define a local ",(0,i.mdx)("inlineCode",{parentName:"li"},"Slots")," that is always mutable, and a separate AST node for referring to it.",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"For modules, it is important that this mutable local ",(0,i.mdx)("inlineCode",{parentName:"li"},"Slots")," is ",(0,i.mdx)("em",{parentName:"li"},"also")," in scope since the scope is used to retrieve unknown variables.")))))}p.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4913],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>d,MDXProvider:()=>c,mdx:()=>f,useMDXComponents:()=>s,withMDXComponents:()=>m});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},o.apply(this,arguments)}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=a.createContext({}),m=function(e){return function(n){var t=s(n.components);return a.createElement(e,o({},n,{components:t}))}},s=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=s(e.components);return a.createElement(d.Provider,{value:n},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),m=s(t),c=r,h=m["".concat(i,".").concat(c)]||m[c]||u[c]||o;return t?a.createElement(h,l(l({ref:n},d),{},{components:t})):a.createElement(h,l({ref:n},d))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=g;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[h]="string"==typeof e?e:r,i[1]=l;for(var d=2;d<o;d++)i[d]=t[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},85256:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>s,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var a=t(87462),r=(t(67294),t(3905));const o={id:"gc"},i="A Moving Garbage Collector",l={unversionedId:"developers/starlark/gc",id:"developers/starlark/gc",title:"A Moving Garbage Collector",description:"This page describes a two-space garbage collector that can deal with cycles.",source:"@site/../docs/developers/starlark/gc.generated.md",sourceDirName:"developers/starlark",slug:"/developers/starlark/gc",permalink:"/docs/developers/starlark/gc",draft:!1,tags:[],version:"current",frontMatter:{id:"gc"},sidebar:"manualSidebar",previous:{title:"Environments",permalink:"/docs/developers/starlark/environment"},next:{title:"Heaps and Heap References",permalink:"/docs/developers/starlark/heaps"}},p={},d=[{value:"A worked example",id:"a-worked-example",level:2}],m={toc:d};function s(e){let{components:n,...t}=e;return(0,r.mdx)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("h1",{id:"a-moving-garbage-collector"},"A Moving Garbage Collector"),(0,r.mdx)("p",null,"This page describes a two-space garbage collector that can deal with cycles."),(0,r.mdx)("p",null,"In Starlark, this pattern is used both when doing a real garbage collection, and when freezing. For both cases, it starts out with a memory block, which has pointers referring to things inside it, and ends up with a new memory block with equivalent pointers inside it. However, only pointers reachable from outside the original memory block are available in the new memory block. The garbage collector can deal with cyclic data structures and the time spent is proportional to the amount of live data in the heap (memory that is dropped is not even visited)."),(0,r.mdx)("h2",{id:"a-worked-example"},"A worked example"),(0,r.mdx)("p",null,"Given a heap with the following layout:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'X := Data("world")\nY := Data("hello", X, Y)\nZ := Data("universe")\n')),(0,r.mdx)("p",null,"All of ",(0,r.mdx)("inlineCode",{parentName:"p"},"X"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"Z")," are memory locations. The ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y")," memory location has both some data of its own (",(0,r.mdx)("inlineCode",{parentName:"p"},'"hello"'),") and two pointers (",(0,r.mdx)("inlineCode",{parentName:"p"},"X")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y")," itself)."),(0,r.mdx)("p",null,"The pointers from outside the heap into the heap are known as ",(0,r.mdx)("em",{parentName:"p"},"roots"),"."),(0,r.mdx)("p",null,"Assuming, in the above example, that ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y")," is the only root, then, since ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y")," is used from outside, ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y")," must be moved to the new memory block. Consequently, the data ",(0,r.mdx)("inlineCode",{parentName:"p"},"X")," needs to be copied, but ",(0,r.mdx)("inlineCode",{parentName:"p"},"Z")," can be dropped."),(0,r.mdx)("p",null,"Following are the required steps for using a garbage collector:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("p",{parentName:"li"},"To copy ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y"),", allocate a value in the new heap ",(0,r.mdx)("inlineCode",{parentName:"p"},"A")," with a sentinel value in it (that that sentinel is called a ",(0,r.mdx)("inlineCode",{parentName:"p"},"Blackhole"),"). Then, turn ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y")," into a ",(0,r.mdx)("inlineCode",{parentName:"p"},"Forward(A)")," pointer, so that if anyone else in this cycle tries to collect ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y"),' they immediately "forward" to the new value and the data from ',(0,r.mdx)("inlineCode",{parentName:"p"},"Y")," is grabbed so its pointers can be traversed. That results in the following:"),(0,r.mdx)("pre",{parentName:"li"},(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'X := Data("world")\nY := Forward(A)\nZ := Data("universe")\n\nA := Blackhole\n')),(0,r.mdx)("p",{parentName:"li"},"With ",(0,r.mdx)("inlineCode",{parentName:"p"},'Data("hello", X, Y)')," as the current item being processed.")),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("p",{parentName:"li"},"Walk the pointers of the current value, performing a garbage collection on each of them. To copy ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y"),", it can be seen that ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y")," points at a ",(0,r.mdx)("inlineCode",{parentName:"p"},"Forward(A)")," node, so there's no need to do anything. To copy ",(0,r.mdx)("inlineCode",{parentName:"p"},"X"),", follow the process starting at step 1, but for ",(0,r.mdx)("inlineCode",{parentName:"p"},"X")," (which ends up at ",(0,r.mdx)("inlineCode",{parentName:"p"},"B"),"). Performing that move leads to the following:"),(0,r.mdx)("pre",{parentName:"li"},(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'X := Forward(B)\nY := Forward(A)\nZ := Data("universe")\n\nA := Blackhole\nB := Data("world")\n'))),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("p",{parentName:"li"},"Replace all the pointers with the forwarded value, and write it back over the ",(0,r.mdx)("inlineCode",{parentName:"p"},"Blackhole")," in ",(0,r.mdx)("inlineCode",{parentName:"p"},"A"),". This gives the following:"),(0,r.mdx)("pre",{parentName:"li"},(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'X := Forward(B)\nY := Forward(A)\nZ := Data("universe")\n\nA := Data("hello", B, A)\nB := Data("world")\n'))),(0,r.mdx)("li",{parentName:"ol"},(0,r.mdx)("p",{parentName:"li"},"Adjust any roots pointing at ",(0,r.mdx)("inlineCode",{parentName:"p"},"Y")," to point at ",(0,r.mdx)("inlineCode",{parentName:"p"},"A")," and throw away the original heap, which produces the following:"),(0,r.mdx)("pre",{parentName:"li"},(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},'A := Data("hello", B, A)\nB := Data("world")\n')))),(0,r.mdx)("p",null,"These above four steps successfully garbage collects a cyclic data structure, while preserving the cycles and getting rid of the unused data."))}s.isMDXComponent=!0}}]);